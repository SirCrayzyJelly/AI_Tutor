[
{
  "model": "admin.logentry",
  "pk": 1,
  "fields": {
    "action_time": "2025-05-11T20:27:19.300Z",
    "user": 1,
    "content_type": 4,
    "object_id": "2",
    "object_repr": "user",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 2,
  "fields": {
    "action_time": "2025-05-11T20:27:47.867Z",
    "user": 1,
    "content_type": 4,
    "object_id": "2",
    "object_repr": "user",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Staff status\", \"User permissions\"]}}]"
  }
},
{
  "model": "auth.permission",
  "pk": 1,
  "fields": {
    "name": "Can add log entry",
    "content_type": 1,
    "codename": "add_logentry"
  }
},
{
  "model": "auth.permission",
  "pk": 2,
  "fields": {
    "name": "Can change log entry",
    "content_type": 1,
    "codename": "change_logentry"
  }
},
{
  "model": "auth.permission",
  "pk": 3,
  "fields": {
    "name": "Can delete log entry",
    "content_type": 1,
    "codename": "delete_logentry"
  }
},
{
  "model": "auth.permission",
  "pk": 4,
  "fields": {
    "name": "Can view log entry",
    "content_type": 1,
    "codename": "view_logentry"
  }
},
{
  "model": "auth.permission",
  "pk": 5,
  "fields": {
    "name": "Can add permission",
    "content_type": 2,
    "codename": "add_permission"
  }
},
{
  "model": "auth.permission",
  "pk": 6,
  "fields": {
    "name": "Can change permission",
    "content_type": 2,
    "codename": "change_permission"
  }
},
{
  "model": "auth.permission",
  "pk": 7,
  "fields": {
    "name": "Can delete permission",
    "content_type": 2,
    "codename": "delete_permission"
  }
},
{
  "model": "auth.permission",
  "pk": 8,
  "fields": {
    "name": "Can view permission",
    "content_type": 2,
    "codename": "view_permission"
  }
},
{
  "model": "auth.permission",
  "pk": 9,
  "fields": {
    "name": "Can add group",
    "content_type": 3,
    "codename": "add_group"
  }
},
{
  "model": "auth.permission",
  "pk": 10,
  "fields": {
    "name": "Can change group",
    "content_type": 3,
    "codename": "change_group"
  }
},
{
  "model": "auth.permission",
  "pk": 11,
  "fields": {
    "name": "Can delete group",
    "content_type": 3,
    "codename": "delete_group"
  }
},
{
  "model": "auth.permission",
  "pk": 12,
  "fields": {
    "name": "Can view group",
    "content_type": 3,
    "codename": "view_group"
  }
},
{
  "model": "auth.permission",
  "pk": 13,
  "fields": {
    "name": "Can add user",
    "content_type": 4,
    "codename": "add_user"
  }
},
{
  "model": "auth.permission",
  "pk": 14,
  "fields": {
    "name": "Can change user",
    "content_type": 4,
    "codename": "change_user"
  }
},
{
  "model": "auth.permission",
  "pk": 15,
  "fields": {
    "name": "Can delete user",
    "content_type": 4,
    "codename": "delete_user"
  }
},
{
  "model": "auth.permission",
  "pk": 16,
  "fields": {
    "name": "Can view user",
    "content_type": 4,
    "codename": "view_user"
  }
},
{
  "model": "auth.permission",
  "pk": 17,
  "fields": {
    "name": "Can add subject",
    "content_type": 5,
    "codename": "add_subject"
  }
},
{
  "model": "auth.permission",
  "pk": 18,
  "fields": {
    "name": "Can change subject",
    "content_type": 5,
    "codename": "change_subject"
  }
},
{
  "model": "auth.permission",
  "pk": 19,
  "fields": {
    "name": "Can delete subject",
    "content_type": 5,
    "codename": "delete_subject"
  }
},
{
  "model": "auth.permission",
  "pk": 20,
  "fields": {
    "name": "Can view subject",
    "content_type": 5,
    "codename": "view_subject"
  }
},
{
  "model": "auth.permission",
  "pk": 21,
  "fields": {
    "name": "Can add qa entry",
    "content_type": 6,
    "codename": "add_qaentry"
  }
},
{
  "model": "auth.permission",
  "pk": 22,
  "fields": {
    "name": "Can change qa entry",
    "content_type": 6,
    "codename": "change_qaentry"
  }
},
{
  "model": "auth.permission",
  "pk": 23,
  "fields": {
    "name": "Can delete qa entry",
    "content_type": 6,
    "codename": "delete_qaentry"
  }
},
{
  "model": "auth.permission",
  "pk": 24,
  "fields": {
    "name": "Can view qa entry",
    "content_type": 6,
    "codename": "view_qaentry"
  }
},
{
  "model": "auth.permission",
  "pk": 25,
  "fields": {
    "name": "Can add content type",
    "content_type": 7,
    "codename": "add_contenttype"
  }
},
{
  "model": "auth.permission",
  "pk": 26,
  "fields": {
    "name": "Can change content type",
    "content_type": 7,
    "codename": "change_contenttype"
  }
},
{
  "model": "auth.permission",
  "pk": 27,
  "fields": {
    "name": "Can delete content type",
    "content_type": 7,
    "codename": "delete_contenttype"
  }
},
{
  "model": "auth.permission",
  "pk": 28,
  "fields": {
    "name": "Can view content type",
    "content_type": 7,
    "codename": "view_contenttype"
  }
},
{
  "model": "auth.permission",
  "pk": 29,
  "fields": {
    "name": "Can add session",
    "content_type": 8,
    "codename": "add_session"
  }
},
{
  "model": "auth.permission",
  "pk": 30,
  "fields": {
    "name": "Can change session",
    "content_type": 8,
    "codename": "change_session"
  }
},
{
  "model": "auth.permission",
  "pk": 31,
  "fields": {
    "name": "Can delete session",
    "content_type": 8,
    "codename": "delete_session"
  }
},
{
  "model": "auth.permission",
  "pk": 32,
  "fields": {
    "name": "Can view session",
    "content_type": 8,
    "codename": "view_session"
  }
},
{
  "model": "auth.user",
  "pk": 1,
  "fields": {
    "password": "pbkdf2_sha256$1000000$ToMxRsI1s6gV9jVcMae2nS$H83lCh4gYaegkzCsDD5FnFK/8KpjpRCKGvg2SGGq7RI=",
    "last_login": "2025-05-11T20:25:21.778Z",
    "is_superuser": true,
    "username": "admin",
    "first_name": "",
    "last_name": "",
    "email": "philippos321@gmail.com",
    "is_staff": true,
    "is_active": true,
    "date_joined": "2025-05-11T20:24:55.947Z",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "auth.user",
  "pk": 2,
  "fields": {
    "password": "pbkdf2_sha256$1000000$tDv1zIwIlB7AiPN3gvPHMf$FOgrIxmQGxpNCigzv2/dtsGC5+uba0DGXWTH0NsRQnw=",
    "last_login": "2025-05-15T19:42:15.228Z",
    "is_superuser": false,
    "username": "user",
    "first_name": "",
    "last_name": "",
    "email": "",
    "is_staff": true,
    "is_active": true,
    "date_joined": "2025-05-11T20:27:18Z",
    "groups": [],
    "user_permissions": [
      1,
      2,
      3,
      4,
      9,
      10,
      11,
      12,
      5,
      6,
      7,
      8,
      13,
      14,
      15,
      16,
      21,
      22,
      23,
      24,
      17,
      18,
      19,
      20,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32
    ]
  }
},
{
  "model": "chatbot.subject",
  "pk": 1,
  "fields": {
    "name": "Programsko inženjerstvo"
  }
},
{
  "model": "chatbot.subject",
  "pk": 2,
  "fields": {
    "name": "Ugradbeni računalni sustavi"
  }
},
{
  "model": "chatbot.subject",
  "pk": 3,
  "fields": {
    "name": "Operacijski sustavi"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 1,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Čime se bavi disciplina programskog inženjerstva te koja su specifična svojstva programskog proizvoda koja ovu inženjersku disciplinu čine posebnom?",
    "answer": "Programsko inženjerstvo (eng. Software Engineering) je disciplina koja se bavi primjenom sustavnog, discipliniranog i kvantificiranog pristupa u razvoju, izvođenju i održavanju programskog proizvoda. Specifična svojstva programskog proizvoda, koja programsko inženjerstvo čine fundamentalno drugačijim od ostalih inženjerskih disciplina, jesu da je on apstraktan, složen, fleksibilan, te teško mjerljivih svojstava. Za razliku od proizvoda svih drugi inženjerskih disciplina, programski proizvod nema fizička svojstva, u bilo kojoj fazi izgradnje može biti izmijenjen i prilagođen, a krajnjem korisniku može biti nedokučiv. Također, ne postoje mjerne jedinice koje su normirane i čija interpretacija može dati odgovore na razne inženjerske probleme koje se susreće prilikom izgradnje i održavanja.",
    "link": "https://www.youtube.com/watch?v=iIxZrYzJJ7I"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 2,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Koja je razlika između programa, sustava čiji su oni dijelovi i programskog proizvoda?",
    "answer": "Pojmom program označavamo isključivo programski kod koji obavlja neki specifični zadatak. Kompozicija programa u složeniju, međusobno povezanu i organiziranu strukturu koja ostvaruje namijenjenu joj funkciju predstavlja sustav. Programski proizvod (eng. software) čini skup programa povezanih u računalne sustave, ali i pripadajuće dokumentacije koji se zajedno isporučuju korisniku.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 3,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Koje su osnovne teme programskog inženjerstva?",
    "answer": "Osnovne teme programskog inženjerstva su: a) Izgradnja velikih i složenih programskih sustava b) Upravljanje složenim strukturama c) Evolucija programskog proizvoda d) Učinkovitost razvoja programskog proizvoda e) Upravljanje komunikacijom u razvoju velikih programskih sustava f) Isporuka kvalitetnog konačnog programskog proizvoda korisniku",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 4,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Što je proces, kako definiramo procese životnog ciklusa programskog proizvoda te od čega se oni sastoje?",
    "answer": "Proces je skup međusobno povezanih aktivnosti kojima se ostvaruje pretvorba ulaza u izlaz. Procesi životnog ciklusa programskog proizvoda definiraju se kao skup procesa, aktivnosti i poslova koje računalni inženjeri izvode kako bi razvili i održavali programski proizvod, a sastoje se od: procesa sklapanja ugovora, procesa poduzeća, projektnih procesa i tehničkih procesa. Ulazi u procesima programskog inženjerstva mogu biti npr. zahtjevi korisnika, zadaci projektnog managementa, testni slučajevi i sl., a pripadni izlazi mogu biti specifikacija zahtjeva, hodogrami aktivnosti, uloge i podjela zadataka, te testno izvješće.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 5,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Što je projekt, kakvi oni mogu biti s obzirom na doseg, a kakvi mogu biti s obzirom na tehničke procese koje izvode?",
    "answer": "Projekt je privremena tvorevina s unaprijed definiranim početkom i završetkom, dosegom i resursima. S obzirom na doseg oni mogu biti:  korektivni projekti (otklanjanje pogrešaka u postojećem sustavu),  adaptivni projekti (izmjene uslijed promjene operacijskog sustava, baza podataka, zakonskih odredbi i sl.),  unapređujući, aditivni projekti (dodavanje nove funkcionalnosti),  projekti ponovnog inženjerstva (npr. unutarnje izmjene u arhitekturi sustava kako bi se olakšalo dodavanje novih modula ili održavanje),  sasvim novi, integrativni projekti (oblikovanje novog okruženja iz postojećih programskih komponenata i cjelina). S obzirom na tehničke procese koje izvode, projekti mogu biti: razvojni projekti (eng. development project), projekti integracije i verifikacije (eng. integration & verification project), i projekti održavanja (eng. maintenance project).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 6,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Koje su osnovne faze u modelima procesa razvoja programskog proizvoda i od čega se sastoje?",
    "answer": "Osnovne faze u modelima procesa razvoja programskog proizvoda prema ISO normama su: inženjerstvo zahtjeva, dizajn, implementacija i testiranje. a) Inženjerstvo zahtjeva je prvi korak svakog modela razvoja, a osnovni cilj mu je opis problema kojeg se treba riješiti i definicija zahtjeva u skladu s zadanim problemom i okolinom kojoj je sustav namijenjen (hardver, drugi software i/ili korisnici). U ovoj fazi provodi se studija izvedivosti projekta, odrede se moguća rješenja te se diskutiraju njihovi prednosti i nedostaci. Osnovni dokument u kojem se sažimaju rezultati ove faze naziva se specifikacija zahtjeva. b) Dizajn podrazumijeva razvoj modela za cijeli sustav kroz (i) dekompoziciju problema na manje smislene programske cjeline (module ili komponente), (ii) prijenos specifikacije zahtjeva sustava na specifikaciju zahtjeva funkcija definiranih programskih cjelina i (iii) definiciju sučelja među programskim cjelinama. Rezultati ove faze sažimaju se u dokumentu tehnička specifikacija. c) Implementacija je faza u kojoj se radi programiranje. Kod velikih programa samom programiranju obično prethodi i ispisivanje pseudokoda. Osnovni cilj programiranja je da se napravi čitljiv, jednostavan za nadogradnju i održavanje, dobro dokumentiran i točan program. Rezultat ove faze je program kojeg se može izvoditi. d) Faza testiranja u novijim modelima razvoja sve je više isprepletena s fazom implementacije. Planiranje testnih aktivnosti započinje s fazom specifikacije zahtjeva. Testiranjem se provjerava u kojoj su mjeri implementirani zahtjevi te se traže neispravnosti kako u kodu, tako i u projektnoj dokumentaciji. Osnovna motivacija za kontinuirano provođenje testnih aktivnosti je da je svaku ranije otkrivenu neispravnost jeftinije ukloniti, tj. ispraviti.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 7,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Koja je osnovna svrha održavanja programskog proizvoda?",
    "answer": "Cilj faze održavanja je osigurati neometano izvođenje programskog proizvoda kod korisnika, a osnovna svrha je: otklanjanje svih neispravnosti otkrivenih nakon isporuke, prilagođavanje sustava promijenjenim zahtjevima ili uvođenje poboljšanja. Održavanje programskih sustava ujedno predstavlja najzahtjevniju aktivnost koja slijedi nakon isporuke, odnosno implementacije software-a",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 8,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Koja je konceptualna razlika između procesa i modela koji se koriste u razvoju software-a?",
    "answer": "Proces je skup međusobno povezanih aktivnosti kojima se ostvaruje pretvorba ulaza u izlaz, dok model predstavlja konkretno definirane korake koje te aktivnosti podrazumijevaju i dinamiku njihova izvođenja. Procesi čije modele treba definirati u okviru životnog ciklusa programskog proizvoda su od razvoja, izvođenja i održavanja projekta, definiranja zahtjeva pa sve do povlačenja programskog proizvoda iz uporabe.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 9,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Kako SEIS doprinosi razvoju društvene odgovornosti u kontekstu razvoja softverskih rješenja?",
    "answer": "SEIS potiče društvenu odgovornost u razvoju softverskih rješenja istražujući njihov tehnološki i društveni utjecaj. Fokusira se na inkluzivnost, etiku i stvarne potrebe zajednice, razvijajući sustave koji povezuju ljude, olakšavaju suradnju i poboljšavaju digitalnu dostupnost.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 10,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Zašto se Ada Lovelace smatra prvom programerkom u povijesti i jesu li njezine ideje bile realizirane?",
    "answer": "Ada Lovelace razvila je prvi algoritam namijenjen izvođenju na stroju. Ne, strojevi koji su trebali raditi na principu njezinih algoritama nikada nisu bili u potpunosti realizirani nego su kasnije poslužili kao temelj za razvoj modernih računala i softvera.",
    "link": "https://en.wikipedia.org/wiki/Ada_Lovelace"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 11,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Kako primjena novih tehnologija poput blockchaina, IoT-a i velikih podataka oblikuje budućnost softverskog inženjeringa i informacijskih sustava (SEIS)?",
    "answer": "Blockchain: Blockchain omogućava sigurno i transparentno pohranjivanje podataka, smanjuje potrebu za posrednicima, što povećava efikasnost i smanjuje troškove u raznim industrijama (npr. financijama, zdravstvu). IoT (Internet stvari): IoT uređaji omogućuju prikupljanje podataka u stvarnom vremenu i automatsko donošenje odluka u industrijama poput zdravstva, pametnih gradova i poljoprivrede, čime se poboljšava efikasnost i kvalitetu usluga. Veliki podaci (Big Data): Analizom velikih podataka, tvrtke i institucije mogu donositi bolje odluke, personalizirati usluge i optimizirati poslovne procese, što doprinosi povećanju konkurentnosti i inovacija.",
    "link": "https://en.wikipedia.org/wiki/Blockchain, https://en.wikipedia.org/wiki/Internet_of_things"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 12,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Koje su dvije glavne kategorije radova koje NIER track prihvaća na ICSE konferenciji i što svaka od njih treba sadržavati?",
    "answer": "• Forward-looking ideas (Vizionarske ideje) – radovi koji predlažu nove smjerove ili tehnike u softverskom inženjerstvu, koji možda nemaju kompletne eksperimentalne dokaze, ali moraju biti jasno argumentirani, potkrijepljeni znanstvenom logikom i sadržavati plan za daljnje istraživanje. • Thought-provoking reflections (Provokativne refleksije) – radovi koji donose neočekivane rezultate ili perspektive koje izazivaju postojeće paradigme u softverskom inženjerstvu, potkrijepljeni preliminarnim podacima ili analizama.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 13,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Što je XDEAD, koje metode koristi za detekciju pogrešno uklonjenog aktivnog koda (zbog grešaka u eliminaciji mrtvog koda - DCE), i koje je dvije specifične greške otkrio?",
    "answer": "• XDEAD je alat za otkrivanje pogrešaka u eliminaciji mrtvog koda (DCE). • Koristi diferencijalno testiranje, statičku binarnu analizu i dinamičko simboličko izvođenje za otkrivanje grešaka. • Konkretno, otkrio je dvije ozbiljne greške u LLVM kompilatoru koje su rezultirale uklanjanjem aktivnog, potrebnog koda tijekom optimizacije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 14,
  "fields": {
    "lecture_id": 1,
    "subject": 1,
    "question": "Koji su glavni izazovi korištenja blockchain tehnologije za koordinaciju robotskih misija u svemiru, i koja četiri rješenja istraživači predlažu za prevladavanje tih izazova?",
    "answer": "• Glavni izazovi uključuju veliku potrošnju energije, sporost obrade transakcija i preveliku transparentnost podataka. • Predložena rješenja uključuju: 1. Prilagođene verzije blockchaina (privatne ili hibridne mreže koje štede energiju i povećavaju brzinu). 2. Pametne ugovore (automatizacija pregovora između robota). 3. Korištenje tokena (fungibilnih ili NFT-ova) za razmjenu informacija ili resursa. 4. Dodatna tehnička optimizacija i razvoj učinkovitijih sustava obrade podataka specifično prilagođenih za uvjete u svemiru.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 15,
  "fields": {
    "lecture_id": 2,
    "subject": 1,
    "question": "Što uključuje planiranje projekata te koji su važni zahtjevi koje pri tome treba zadovoljiti?",
    "answer": "Planiranje projekata uključuje:  Određivanje zadataka i njihovih međusobnih ovisnosti o Svaki zadatak bi trebao imati jasno definiranu i provjerljivu isporuku i vremenski rok  Određivanje poretka obavljanja zadataka i potrebnih resursa o Zadaci bi se trebali poredati tako da se izvedu u što kraće vrijeme, bez praznog hoda  Predviđanje trajanja projekta o Dobrim planiranjem zadataka i količine vremena koja je za njih potrebna  Predviđanje troškova o Ovisi o uspješnosti procjene veličine i/ili složenosti projekta  Mehanizmi praćenja i kontrole kvalitete Trokut zahtjeva, često proturječnih u razvoju programskog proizvod, koje treba pokriti planiranjem su: trajanje, troškovi i kvaliteta. Nemoguće je postići brz, jeftin i kvalitetan projekt, ali na uštrb jednog zahtjeva, moguće je postići dobre rezultate u druga dva (npr. brz i jeftin projekt vrlo vjerojatno neće biti naročito kvalitetno izveden).",
    "link": "https://blog.pragmaticengineer.com/how-to-lead-a-project-in-software-development/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 16,
  "fields": {
    "lecture_id": 2,
    "subject": 1,
    "question": "Čemu služi, što sadrži i koja su pravila za strukturu podjele posla (eng. Work breakdown structure)?",
    "answer": "Struktura podjele posla (eng. Work breakdown structure, WBS) je tehnika za podjelu posla u manje zadatke što je neophodno prilikom planiranje složenijeg projekta. WBS uključuje definiciju isporuka (eng. deliverables) i ključnih datuma (eng. milestones) u formi WBS stabla koje sadrži:  Poslove složene po razinama  Najviše razine su obično veliki poslovi zajednički svim projektima (npr. specifikacija zahtjeva, dizajn, verifikacija)  Poslove više razine se granaju na više poslova niže razine  Poslove najniže razine zovu se zadaci (listovi stabla) Pravila za konstrukciju WBS stabla su:  WBS mora imati strukturu stabla, dakle, bez petlji i ciklusa (iterativni poslovi se definiraju procesom, a ne u WBS-u)  Opisi zadataka moraju biti razumljivi i nedvosmisleni  Svaki zadatak mora imati nedvosmislen kriterij za provjeru da je izvršen (najčešće je to isporuka - deliverable)  Sve isporuke moraju biti identificirane s WBS-om, tj. svaka isporuka potrebna u projektu mora biti proizvod nekog od zadataka  Uspješno izvršenje svih poslova neke razine mora rezultirati uspješnim izvršenjem posla na razini iznad",
    "link": "https://www.youtube.com/watch?v=BVcd9uy9kuQ"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 17,
  "fields": {
    "lecture_id": 2,
    "subject": 1,
    "question": "Što je, od čega se sastoji i čemu služi program evaluation and review technique?",
    "answer": "Program Evaluation and Review Technique (PERT) je tehnika za izradu grafa koji prikazuje međusobne ovisnosti i trajanja svih zadataka u nekom poslu. Vrhovi (čvorovi) grafa predstavljaju zadatke, oznake vrhova prikazuju trajanja zadataka, a bridovi (veze) grafa povezuju zadatak sa svim zadacima koji o njemu ovise (strelica pokazuje u tom smjeru). Pomoću grafa se određuju vrijeme izvršavanja čitavog posla, kritični put, te dozvoljena kašnjenja zadataka",
    "link": "https://www.youtube.com/watch?v=i160aaBX7mE"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 18,
  "fields": {
    "lecture_id": 2,
    "subject": 1,
    "question": "Što je kritični put kod program evaluation and review technique-a?",
    "answer": "- Kritični put je niz ovisnih zadataka čije izvršenje traje koliko i minimalno moguće trajanje čitavog posla - Kritični put (ovisnosti u njemu) je razlog zbog kojeg čak ni korištenjem više resursa nije moguće ubrzati završetak posla - Kritični put ne mora biti jedinstven, ali svi mogući kritični putovi jednako traju",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 19,
  "fields": {
    "lecture_id": 2,
    "subject": 1,
    "question": "Objasni metodologiju CAPIR metode za poboljšanje preporuka API-ja u procesu generiranja koda.",
    "answer": "Prvi korak -> raščlaniti zadatak gdje se LLM treba koristiti na manji niz podzadataka. Drugi korak -> pretraživanje API-ja gdje CAPIR pretražuje dokumentaciju kako bi pronašao relevantne API-je za svaki podzadatak. Treći korak -> rangiranje API-ja, CAPIR ocjenjuje i filtrira pronađene API-je kako bi preporučio samo one najrelevantnije za zadani podzadatak.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 20,
  "fields": {
    "lecture_id": 2,
    "subject": 1,
    "question": "Kvalitetna dokumentacija ASAT pravila trebala bi sadržavati koja tri ključna elementa i na što bi oni trebali odgovarati?",
    "answer": "Što? - Objašnjenje što aktivira određeno pravilo, odnosno koji problem u kodu se detektira. Zašto? - Razlog zašto je određeno pravilo važno te kakve posljedice može imati ako se ne poštuje. Kako ispraviti? - Konkretne smjernice ili primjeri kako riješiti problem koji je alat detektirao.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 21,
  "fields": {
    "lecture_id": 2,
    "subject": 1,
    "question": "Što je Mask-Catcher i kako glasi njegova metodologija?",
    "answer": "Mask-Catcher je automatizirani sustav koji koristi mehanizam filtriranja za detekciju maskiranih aplikacija. Prvi korak -> razvrstavanje aplikacija prema nesuglasju između opisa aplikacije i recenzija korisnika. Drugi korak -> stvaranje mreže preporuka među aplikacijama pomoću međusobnih preporuka. Treći korak -> analiza sličnosti za otkrivanje aplikacija koje koriste skrivene funkcionalnosti.",
    "link": "https://www.ittc.ku.edu/~bluo/pubs/zhao24icpc.pdf"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 22,
  "fields": {
    "lecture_id": 3,
    "subject": 1,
    "question": "Što je menadžment u programskom inženjerstvu prema IEEE i koji su stvarni problemi?",
    "answer": "Menadžment u programskom inženjerstvu je primjena aktivnosti poput planiranja, nadzora i kontrole s ciljem sustavnog razvoja softvera. U praksi se susreću problemi poput postavljanja prioriteta, rada s nejasnim ulazima, koordinacije timova, kontrole apstraktnih proizvoda i komunikacije.",
    "link": "https://sceweb.sce.uhcl.edu/helm/SWEBOK_IEEE/data/swebok_chapter_08.pdf"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 23,
  "fields": {
    "lecture_id": 3,
    "subject": 1,
    "question": "Koje su važne karakteristike koje definiraju projekt?",
    "answer": "Projekt je vremenski ograničen s definiranim početkom i krajem, ograničenim resursima i nizom aktivnosti koje se izvode logičkim redoslijedom kako bi se stvorio jedinstveni rezultat.",
    "link": "https://pressbooks.ulib.csuohio.edu/project-management-navigating-the-complexity/chapter/1-2-project-characteristics/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 24,
  "fields": {
    "lecture_id": 3,
    "subject": 1,
    "question": "Koja je razlika između linijske i projektne odgovornosti?",
    "answer": "Linijska odgovornost se odnosi na strateške zadatke unutar organizacije (npr. upravljanje resursima), dok se projektna odgovornost odnosi na ispunjenje ciljeva određenog projekta (npr. isporuka u roku i budžetu).",
    "link": "https://www.sprintzeal.com/blog/project-characteristics"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 25,
  "fields": {
    "lecture_id": 3,
    "subject": 1,
    "question": "Koje procese upravljanja uključuje životni ciklus projekta?",
    "answer": "Uključuje procese: inicijacije (studije izvedivosti), planiranja (razrada faza), izvođenja i kontrole, te završne procese poput revizije i zaključenja projekta.",
    "link": "https://biz.libretexts.org/Courses/Western_Technical_College/Operations_Management_%28Hammond%29/05%3A_Project_Management/5.03%3A_Project_Characteristics_and_Constraints"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 26,
  "fields": {
    "lecture_id": 3,
    "subject": 1,
    "question": "Koja su ključna znanja za upravljanje softverskim projektima?",
    "answer": "Potrebna znanja uključuju: modele procesa, upravljanje timovima, kvalitetom, rizicima, komunikacijom, troškovima, vremenom i konfiguracijama, kao i planiranje i nadzor.",
    "link": "https://en.wikipedia.org/wiki/Software_Engineering_Body_of_Knowledge"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 27,
  "fields": {
    "lecture_id": 3,
    "subject": 1,
    "question": "Što je projektni plan i kada se izrađuje?",
    "answer": "Projektni plan je temeljni dokument koji opisuje kako ?e se projekt voditi i nadzirati. Prva verzija se izrađuje na početku, već u fazi zahtjeva, i s vremenom se ažurira.",
    "link": "https://www.sprintzeal.com/blog/project-characteristics"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 28,
  "fields": {
    "lecture_id": 3,
    "subject": 1,
    "question": "Koja su osnovna poglavlja projektnog plana i što sadrže?",
    "answer": "1. Organizacija projekta: model procesa, projektna struktura, granice, odgovornosti. 2. Proces upravljanja: rizici, kontrolni mehanizmi, izvještavanje, planiranje ljudskih resursa. 3. Tehnički procesi: alati, metode, dokumentacija, osiguranje kvalitete. 4. Vremenski tijek: radni paketi, rokovi, resursi, budžet.",
    "link": "https://www.sprintzeal.com/blog/project-characteristics"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 29,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Koja je razlika između modela procesa i procesa životnog ciklusa?",
    "answer": "Proces životnog ciklusa obuhvaća sve aktivnosti koje ljudi izvode kako bi razvili, održavali i povukli programski proizvod – uključuje sklapanje ugovora, tehničke i projektne procese. Model životnog ciklusa je formalni okvir koji definira redoslijed i dinamiku tih aktivnosti, kao i njihovu međusobnu povezanost, te pruža strukturu od početka do kraja razvoja softvera. Drugim riječima, proces opisuje \"što se radi\", a model \"kako i kada\".",
    "link": "https://www.fer.hr/_download/repository/PP10.pdf?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 30,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Koje su osnovne faze općeg modela životnog ciklusa softvera?",
    "answer": "Faze su: 1. Inženjering zahtjeva – korisnički zahtjevi se formaliziraju u tehničke specifikacije. 2. Tehnički dizajn – tehnički zahtjevi se prevode u dizajnersku dokumentaciju. 3. Implementacija – koristi dizajn za kodiranje funkcionalnog proizvoda. 4. Testiranje – provjerava radi li implementacija ispravno. Svaka faza ima jasne ulaze i izlaze, a isporuke jedne faze su potrebne za sljedeću.",
    "link": "https://www.guru99.com/hr/software-development-life-cycle-tutorial.html?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 31,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Koje su osnovne karakteristike vodopadnog modela razvoja?",
    "answer": "Vodopadni model je linearan, gdje se svaka faza (od analize do testiranja) završava prije nego što počne sljedeća. Karakteristike: Faze su strogo odvojene i ne preklapaju se. Pogodan za projekte s dobro definiranim zahtjevima. Prednosti: Jednostavnost u planiranju i provedbi. Jasna struktura i dokumentacija. Nedostaci: Nema povratka unatrag ako se pojave problemi. Promjene zahtjeva teško se integriraju. Korisnik dobiva gotov proizvod tek na kraju, što smanjuje povjerenje.",
    "link": "https://spvp.zesoi.fer.hr/seminari/2007/seminari/Ivo%20Veseli%20-%20Proces%20razvoja%20softvera.pdf?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 32,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Koje su prednosti i nedostaci prototyping modela razvoja i kada se primjenjuje?",
    "answer": "Prototyping model uključuje izradu nedovršenog (ali vizualnog) rješenja kako bi se dobila povratna informacija od korisnika. Prednosti: Bolje razumijevanje korisničkih zahtjeva. Rano otkrivanje problema. Manje nepotrebnih funkcionalnosti, jednostavniji sustav. Nedostaci: Može biti vremenski zahtjevno. Često se preskaču standardi i kvaliteta dizajna. Otežano održavanje zbog tehničkog duga. Primjena: Kad nisu jasni zahtjevi na početku, posebno korisničko sučelje.",
    "link": "https://repository.inf.uniri.hr/islandora/object/infri%3A468/datastream/PDF/download?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 33,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Koje su osnovne karakteristike inkrementalnog modela razvoja?",
    "answer": "Softver se razvija u dijelovima (inkrementima), svaki od njih djeluje samostalno. Karakteristike: Iterativan razvoj s djelomičnim isporukama. Korisnik može rano koristiti dijelove sustava. Prednosti: Rani povrat informacija. Fleksibilniji prema promjenama. Veće povjerenje korisnika. Nedostaci: Kompleksno planiranje. Potrebni iskusni stručnjaci. Teškoća u integraciji svih dijelova kasnije.",
    "link": "https://www.guru99.com/hr/what-is-incremental-model-in-sdlc-advantages-disadvantages.html?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 34,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Koje su osnovne karakteristike spiralnog modela razvoja?",
    "answer": "Spiralni model kombinira iteracije i analizu rizika kroz više ciklusa razvoja. Karakteristike: Svaka iteracija uključuje komunikaciju, planiranje, analizu rizika, dizajn, izradu i evaluaciju. Fokus na analizu i minimizaciju rizika. Prednosti: Visoka fleksibilnost. Aktivna uključenost korisnika. Rano uočavanje problema. Nedostaci: Složena struktura. Teškoća u upravljanju. Nije idealan za velike sustave s dugim razvojem.",
    "link": "https://zir.nsk.hr/islandora/object/unipu%3A6218/datastream/PDF/download?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 35,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Što je osnovna ideja modela zasnovanog na ponovnoj upotrebi i zašto nije široko zastupljen?",
    "answer": "Ideja je korištenje gotovih komponenti (\"lego pristup\") – analiza, prilagodba i integracija postojećih modula. Problem: Nedostatak iskustva i nedovoljna baza kvalitetnih komponenti u industriji.",
    "link": "https://jusufspahic.files.wordpress.com/2015/11/dizajn-aplikativnog-softvera-skripta-za-kolokvijum.pdf?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 36,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Koje su osnovne karakteristike rapidnog modela razvoja?",
    "answer": "Faze razvoja se preklapaju (npr. dizajn i implementacija). Inkrementalni razvoj s čestim verzijama (svakih 2–3 tjedna). Minimalna dokumentacija. Fokus na brzu isporuku i fleksibilnost. Aktivna uključenost korisnika. Mali timovi, neformalna komunikacija.",
    "link": "https://repozitorij.veleri.hr/islandora/object/veleri%3A2512/datastream/PDF/view?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 37,
  "fields": {
    "lecture_id": 4,
    "subject": 1,
    "question": "Usporedi agilne metode razvoja: Scrum, Kanban i Scrumban.",
    "answer": "Scrum: Fiksni vremenski sprintovi (obično 2 tjedna). Jasno definirane uloge (scrum master, product owner). Planiranje, dnevni sastanci, retrospektive. Promjene nisu dozvoljene unutar sprinta. Kanban: Vizualna ploča s karticama (To Do, Doing, Done). Bez vremenskih ograničenja. Promjene se mogu unositi u hodu. Fokus na optimizaciju tijeka rada. Scrumban: Kombinira najbolje iz oba svijeta. Sprintovi poput Scruma + fleksibilnost Kanbana. Ograničen broj zadataka u tijeku (WIP limit). Koristi vizualizaciju radnog procesa.",
    "link": "https://gorankrmpotic.eu/agile-agilno-upravljanje-scrum-kanban?utm_source=chatgpt.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 38,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Što je zahtjev i kako do njega dolazimo u inženjerstvo zahtjeva?",
    "answer": "Zahtjev je stanje ili sposobnost koje je programski sustav treba posjedovati kako bi pomogao njegovom korisniku u rješavanju problema i/ili dostizanju ciljeva. U inženjerstvu zahtjeva različiti korisnici mogu predlagati zahtjeve, iako se najčešće za funkcionalne zahtjeve konzultira krajnji korisnik. Inženjerstvo zahtjeva je pri tome iterativan i kooperativan proces analize, dokumentiranja rezultata analize te kontinuirane provjere ispravnosti razumijevanja postignutog tim radnjama, koji rezultate opisuje u dokumentu specifikacija zahtjeva (eng. Requirement specification).",
    "link": "https://www.youtube.com/watch?v=jb0rpHb6gE0"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 39,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Koje karakteristike moraju imati dobro specificirani zahtjevi?",
    "answer": "Dobro specificirani zahtjevi moraju biti točni, potpuni (sadržavati sve potrebne zahtjeve), konzistentni (međusobno usklađeni, nema kontradikcije), koncizni (nema duplikata), prioretizirani (definirani prema važnosti), jednostavno provjerljivi, modularni (kako bi se jednostavnije mijenjali i prilagođavali) te sljedivi (prema drugim dokumentima), a ne smiju biti dvoznačni ili višeznačni.",
    "link": "https://www.youtube.com/watch?v=Z9mKgHbfPpE"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 40,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Je li sljedeći zahtjev dobro specificiran: „Sustav treba pohraniti sve važne korisničke informacije“. Obrazložiti odgovor.",
    "answer": "Navedeni primjer nije dobro specificiran. Nejasan je, ne zna se koje korisničke informacije su važne, nije provjerljiv niti jednoznačan.",
    "link": "https://www.youtube.com/watch?v=jb0rpHb6gE0"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 41,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Je li sljedeći zahtjev dobro specificiran: „Sustav treba biti dostupan 24 sata na dan, 7 dana u tjednu.“ Obrazložiti odgovor.",
    "answer": "Navedeni primjer je dobro specificirani zahtjev iako se ne tiče funkcionalnosti. Sve potrebne informacije su navedene, provjerljiv je, jednoznačan, razumljiv, tehnički izvediv i ne predefinira implementaciju.",
    "link": "https://www.youtube.com/watch?v=jb0rpHb6gE0"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 42,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Za što je sve specifikacija zahtjeva važna?",
    "answer": "Specifikacija zahtjeva definira koje će zahtjeve programski sustav zadovoljavati, a koristi se za kao osnova pri sklapanju ugovora sa naručiteljem, kao ulaz u fazu dizajna tehničke solucije, ulaz za specifikaciju testnih slučaja, te kao važna dokumentacija za inženjere koji vrše validaciju sustava, menadžere i sl.",
    "link": "https://www.youtube.com/watch?v=jb0rpHb6gE0"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 43,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Navedi osnovne faze procesa inženjerstva zahtjeva i skiciraj okvir tog procesa.",
    "answer": "U procesu inženjerstva zahtjeva možemo razlikovati tri osnovne faze: pronalaženje i analiza zahtjeva (eng. Req. Elicitation), dokumentiranje zahtjeva (eng. Req. specification) te provjera zahtjeva (eng. Req. Validation and verification).",
    "link": "https://www.youtube.com/watch?v=Z9mKgHbfPpE"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 44,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Što je cilj i na koje se probleme nailazi u pronalaženju zahtjeva?",
    "answer": "Cilj pronalaženja zahtjeva je pronaći točne i potpune zahtjeve. Problemi, na koje se pri tome nailazi, su (i) da znanja iz neke domene se obično podrazumijevaju i neka neformalna znanja koja je teško dohvatiti (gdje do izražaja može doći socijalna i spoznajna sposobnost analitičara), (ii) zahtjevi su često kompleksni i postoji velik broj mogućnosti koje se može izvesti programskim proizvodom, a korisnik rijeko uspije iz prvog pokušaja sagledati sve aspekte svojih želja te (iii) teško je nositi se s razvojem okoline, tj. osigurati perspektivne zahtjeve koji će služiti i u budućnosti",
    "link": "https://www.youtube.com/watch?v=Z9mKgHbfPpE"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 45,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Opiši različite korisnike dokumenta specifikacije zahtjeva te što je svakome od njih važno.",
    "answer": "Specifikacija zahtjeva je korištena od strane: a. Završnih korisnika (eng. Customers), koji bi trebali provjeriti da opisani sustav odgovara njihovim potrebama. Za korisnike, zahtjevi trebaju biti jednostavni i razumljivi, sa minimalnim žargonom, kako bi imali “čistu” komunikaciju. b. Dizajnera, koji trebaju izraditi dizajn sustava koji je opisan kroz zahtjeve. Zahtjevi moraju biti cjeloviti, jasni i što točniji kako bi se iz njih mogao razviti točan dizajn. Također, trebali bi identificirati sva ograničenja sustava kako bi ih dizajn mogao inkorporirati c. Testera, koji trebaju izraditi testne skripte. Zahtjevi trebaju biti što precizniji, kako bi se mogle definirati konkretne ulazne i izlazne vrijednosti za testne slučajeve. d. Dokumentacije, koja bi trebala sadržavati i korisničke upute proizašle iz zahtjeva. Kao i za same korisnike, dokumentacija također zahtjeva jasne zahtjeve koji prenose sve opcije sustava.",
    "link": "https://www.youtube.com/watch?v=jb0rpHb6gE0"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 46,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Nabroji i opiši tehnike ispitivanja korisnika koje se koriste u pronalasku i analizi zahtjeva? Koje od navedenih tehnike služe za planiranje budućeg razvoja?",
    "answer": "Tehnike ispitivanja koje se koriste u pronalasku zahtjeva su intervju, brainstorm, upitnici (questionariee) te Delphi tehnika, tehinka analize zadataka (Task analysis) i tehnika analize zasnovane na scenarijima (Scenario based analysis).  Intervju, brainstorm i upitnici se uglavnom svode na ispitivanje korisnika i njegova očekivanja od sustava o Osnovni problemi ovakvih tehnika su da korisnici često predvide svoja ograničenja i predrasude  Delphi je iterativna tehnika gdje korisnici izmjenjuju informacije u pisanoj formi dok god se ne postigne sporazum  Tehinka analize zadataka (Task analysis) se temelji na dekompoziciji niza zadataka koje korisnici izvode u svom poslu  Tehnika analize zasnovane na scenarijima (Scenario based analysis) se ne fokusira na zadatke već na slijed zadatka o Svaki scenarij objašnjava kako se slijed zadatka izvodi o tehnika se obično koristi u objektno orijentiranim analizama i dizajn metodama (Use Case analysis) Od navedenih tehnika brainstorm tehnika se primjenjuje za planiranje budućeg razvoja, a tehnika analize zasnovana na scenarijima se može koristiti i za modeliranje trenutnog i budućeg razvoja. Tehnika prototipova (Prototyping) je tehnika koja na osnovu inicijalnog skupa zahtjeva razvija prototip, na osnovu kojeg se dalje definiraju zahtjevi budućeg razvoja, a također uključuje korisnika.",
    "link": "https://www.youtube.com/watch?v=Z9mKgHbfPpE"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 47,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Nabroji i opiši tehnike koje se koriste u pronalasku i analizi zahtjeva, a ne uključuju korisnika? Koje od navedenih tehnike služe za planiranje budućeg razvoja?",
    "answer": "Tehnike za pronalazak i analizu zahtjeva, a ne uključuju korisnika, već informacije prikuplja iz znanja o domeni su: etnografija (Etnography), analiza formularima (Form analysis), opisi prirodnog jezika (Natural language descriptions), derivacija iz postojećih sustava (Derivation from an existing system) te redizajn poslovnog procesa (Business process redesign).  Etnografija je tehnika u kojoj se analizira kako grupa ljudi u stvarnosti radi, a ne kako je propisan poslovni process  Analiza formularima je tehnika u kojoj se informacije o domeni dobivaju iz raznih formulara koji se koriste u stvarnom procesu  Opisi prirodnog jezika je tehnika slična analizi formulara, samo što se informacije prikupljaju iz raznih opisnih dokumentacija primjerice operacijskih instrukcija i priručnika  Derivacija iz postojećih sustava je tehnika u kojoj se zahtjevi formuliraju tako da se analiza započne od nekog postojećeg sustava  redizajn poslovnog procesa je tehnika koja se koristi kada se želi potpuno izmijeniti i automatizirati poslovni model neke organizacije, koristi formalnu metodologiju, ne spada baš u skupinu tehnika pronalaženja i analize zahtjeva  Prototyping je tehnika koja na osnovu inicijalnog skupa zahtjeva razvija prototip, na osnovu kojeg se dalje definiraju zahtjevi",
    "link": "https://www.youtube.com/watch?v=Z9mKgHbfPpE"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 48,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Koji su važni zahtjevi koje imamo za dokument specifikacije zahtjeva?",
    "answer": "Dokument specifikacije zahtjeva treba sadržavati: funkcionalnosti (što programski proizvod treba raditi), vanjska sučelja (kako programski proizvod međudjeluje s okolinom - ljudima, sistemskim hardverom, drugim hardverom i programskim proizvodima), performanse (koja je brzina, dostupnost, vrijeme odaziva, vrijeme oporavka različitih funkcija programskog proizvoda), atribute (analiza svojstva atributa kvalitete poput prenosivosti, točnosti, jednostavnosti održavanja, sigurnosti, pouzdanosti), ograničenja zbog implementacije (organičenja resursa, integritet baze podataka, operativni sustav, standardi).",
    "link": "https://www.youtube.com/watch?v=Z9mKgHbfPpE"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 49,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Koje poglede razlikujemo u općem opisu sustava prema normi IEEE 830?",
    "answer": "Product perspective: Opis programskog proizvoda iz perspektive njegova djelovanja i njegove interakcije s drugim proizvodima, gdje je potrebno identificirati sve uvjete rada: o sučelja s sustavom, korisnikom, hardverom, drugim programima, komunikacijska sučelja, korištenje memorije, načini/uvjeti izvođenja, zahtjevi uslijed određene primjene  Product functions: Kratki opis svih funkcija koje pp treba izvoditi  User characteristics: Opis nužnih karakteristika korisnika za rukovanje  Constraints: Opis ograničenja u razvoju programskog proizvoda (primjerice razne regulative, ograničenja hardvera, sučelja prema drugim funkcijama, mogućnost paralelnog rada, funkcije audita i kontrole, pouzdanost, sigurnost, i druga moguća ograničenja na dizajn funkcije)  Assumptions and dependencies: Opis pretpostavki i zavisnosti izvođenja programskog proizvoda o drugim elementima s kojima je u interakciji. Za razliku od ograničenja na dizajn ovdje se navode moguća ograničenja na izvođenje programskog proizvoda  Apportioning of requirements: Lista mogućih zahtjeva u budućim revizijama dokumenta",
    "link": "https://www.youtube.com/watch?v=jb0rpHb6gE0"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 50,
  "fields": {
    "lecture_id": 5,
    "subject": 1,
    "question": "Kojih se smjernica trebamo pridržavati u navođenju zahtjeva i koje nam tehnike mogu pri tome pomoći?",
    "answer": "Smjernice kojih se treba pridržavati u navoženju zahtjeva su:  zahtjevi trebaju biti DOBRO specificirani, međusobno referencirani, jedinstveni i organizirani u smislene skupine  dokumentirani zahtjevi se trebaju promatrati i iz korisniče i iz implementacijske perspektive  govorni jezik je zbog svojih nedostataka (šum, tišina, prespecificiranost, kontradiktornost, dvosmislenost, nestrukturiranost, maglovitost) poželjno zamijeniti formalnim jezikom Tehnike koje nam pomažu pri formaliziranju jezika su:  Entity-Relationship modeliranje koje modelira logičke i semantičke strukture, a sadrži entitete (grupacije zajedničkih karakteristika), atribute (karakteristike entiteta), veze (smislene poveznice između entiteta koje mogu imati pridodanu brojnost)  Konačni automati (eng. Finite state machines) koji se koriste za konačni broj stanja i mogućih prijelaza. Posebno se definirana inicijalno stanje, a dijagram prijelaza stanja koriste kružnice za prikaz stanja i usmjerene putanje za prikaz prijelaza stanja s opisom (labelom) što je pokrenulo prijelaz (stimulans)",
    "link": "https://www.youtube.com/watch?v=jb0rpHb6gE0"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 51,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Što je i čemu služi UML te što sadrži?",
    "answer": "UML jedan je od prvih koraka standardizacije discipline programskog inženjerstva, a služi kao norma za kreiranje modela sustava. Model sustava je potpuni opis sustava promatran iz određene perspektive. UML sadrži standardiziranu notaciju s predloženim dijagramima koji služe za izgradnju modela programskih sustava. Sadrži specifikacije 9 različitih dijagrama koji služe kako bi se dokumentirale različite perspektive rješenja programskog proizvoda, iz različitih faza životnog ciklusa programskog proizvoda, od kojih 7 za modeliranje zahtjeva i dizajn te 2 za opis implementacije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 52,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Kako dijelimo UML dijagrame s obzirom na različite perspektive?",
    "answer": "UML dijagrame dijelimo na 3 perspektive: funkcionalna, dinamička i statička. Funkcionalna perspektiva opisuje kako sustav treba raditi te njoj pripadaju: 1. Dijagram korištenja (eng. use case diagram) koji opisuje svojstva koja korisnik ima na raspolaganju, odnosno koja očekuje od sustava te kojim redoslijedom se ona pogone 2. Dijagram aktivnosti (eng. activity diagram) koji opisuje procese za ostvarenje svojstva sustava u obliku niza zadataka koji se moraju obaviti, uvjetnih logika i istovremenih obrada Statička perspektiva opisuje građevne elemente sustava, ali ne i način njihova međudjelovanja. Tipični predstavnici su: 1. Dijagram razreda (eng. Class diagram) koji daje pogled na sve resurse (razrede) i njihova svojstva. Gotovo uvijek se koristi za generaciju koda i reverzno inženjerstvo. 2. Dijagram objekata (eng. Object diagram) konkretizira općenitu sliku sustava prikazanu dijagramom razreda kroz konkretne instance (nalik testnim klasama) Dinamička perspektiva opisuje ponašanje sustava kojeg modeliramo tako što opisuje kako elementi iz statičkih dijagrama međusobno djeluju na neki poticaj iz okoline te njoj pripadaju: 1. Dijagrami slijeda i suradnje (eng. Sequence and collaboration diagram) koji opisuju interakcije među objektima u izvođenju programa sa ili bez vremenske perspektive 2. Dijagram karte stanja (eng. Statechart diagram) koji opisuje kako i zašto se objekti mijenjaju za vrijeme odgovora sustava na neki vanjski poticaj",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 53,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Čemu služi Use Case model? Opiši osnovne načine za opis zahtjeva koje model koristi.",
    "answer": "UC model je skup dijagrama i pripadajućeg teksta kojim se opisuje način međudjelovanja sustava s korisnikom na način kakav korisnik očekuje. UC model koristi tri načina opisa zahtjeva: UC dijagram kojemu je osnovni cilj objasniti na visokom nivou veze između sustava i okoline, UC opis (eng. use case narrative) koji čini opisni dodatak dijagramu kako bi se bolje objasnila korisnička očekivanja kroz pretpostavke, preduvjete, način pokretanja UC-a, proces ili dijalog, završetak UC-a i postuvjete, te UC scenariji (eng. use case scenarios) kod kojih svaki predstavlja jednu moguću izvedbu ili logičku putanju UC-a, odnosno definira što se događa sa sustavom pod određenim uvjetima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 54,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Nacrtati primjer upotrebe <> i <> odnosa između elemenata Use Case dijagrama te obrazložiti zašto su elementi baš u tom odnosu.",
    "answer": "Na slici je prikazan primjer sustava bankomata koji korisniku (eng. customer) nudi opciju podizanja gotovine (eng. withdraw cash) i podizanja gotovine sa zaštitom odlaska u minus (eng. protect overdraft). Kod odabira opcije podizanja gotovine automatski se pokreće prikaz ažuriranja stanja na računu (eng. update account), a kod opcije podizanja gotovine sa zaštitom postavlja se pitanje želi li se aktivirati zaštita i ako je odgovor potvrdan, pokreće se odgovarajući prikaz. Oznaka <> se koristi kada jedan UC sigurno koristi drugi UC u obavljanju svog zadatka. U ovom primjeru „Withdraw Cast“ sigurno poziva „Update Account“. Oznaka <> se koristi kada jedan UC može trebati pomoć drugog UC-a u izvođenju svog zadatka. To znači da u kodu UC-a koji treba pomoć postoji proširenje, odnosno uvjetno grananje kojim se omogućuje pozivanje drugog UC-a. U ovom primjeru „Protect Overdraft“ je opcija koja može i ne mora biti pozvana kao zaseban UC nakon odabira „Withdraw Cash with Overdraft Protection“.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 55,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Nabroji i opiši sastavne elemente Use Case dijagrama?",
    "answer": "Sastavni elementi Use Case dijagrama su: sustav, korisnik, korisnički slučaj te veze: pridruživanje, zavisnost unutar sustava koja može biti uključivanje ili proširivanje te generalizacija. Sustav se označava pravokutnikom, a važno je definirati koliko funkcionalnosti sadrži, kako međudjeluje sa okolnim sustavima, te tko su korisnici sustava. Korisnik je predstavljen grafikom čovječuljka za ljude ili pravokutnikom za druge sustave i uređaje koji imaju interakciju sa sustavom. Korisnički slučaj je označen elipsom unutar sustava te definira zahtijevano ponašanje sustava, odnosno svojstva koja su vidljiva korisnicima. Veze označene strelicama određuju komunikaciju korisnika sa sustavom (pridruživanje). Veze označene isprekidanom linijom označavaju odnos unutar sustava, odnosno korisničkih slučaja. Veza odnosa označena sa <> označava kada jedan korisnički slučaj koristi drugi korisnički slučaj u izvođenju svoga zadatka, a označena sa <> označava kada jedan korisnički slučaj koristi drugi korisnički slučaj u izvođenju svoga zadatka uz određeni uvjet. Veze označene punom linijom i praznim trokutićem definiraju generalizaciju korisničkih slučajeva kod kojeg jedan korisnički slučaj predstavlja općenitiju verziju drugoga, odnosno sadrži sva svojstva i ima potpuni pristup drugom korisničkom slučaju.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 56,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Za što se koristi te koji su osnovni elementi dijagrama aktivnosti (eng. activity diagram)? ",
    "answer": "Dijagram aktivnosti prikazuje funkcionalnost programskog sustava iz perspektive unutrašnjosti sustava. Sastavni elementi su mu: početno i krajnje stanje (označeni krugovima), aktivnosti (pravokutnikom) koje mogu biti slijedne ili paralelne, prijelazi između aktivnosti, odnosno tok aktivnosti (strelicom), račvanje i skupljanje paralelnih aktivnosti (podebljanom linijom), uvjetno grananje (rombom) te signali kada neka aktivnost šalje ili prima neku poruku (zastavicom).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 57,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Koja je osnovna razlika između scenarija i dijagrama aktivnosti?",
    "answer": "Dijagram aktivnosti prikazuje sve moguće sekvence odjednom, a scenarij je samo jedna moguća putanja/izvedba dijagrama aktivnosti.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 58,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Koja je glavna prednost potpuno automatskih sustava za ispravljanje grešaka u programskom kodu?",
    "answer": "Glavna prednost potpuno automatskih sustava je njihova brzina i smanjena potreba za ljudskim resursima, jer cijeli proces – od detekcije greške do generiranja popravka – odvija se bez intervencije programera, koristeći samo testove kao ulaz. ",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 59,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Koje vrste grešaka APR alati poput SemFix i SapFix mogu automatski ispraviti, i kako to čine?",
    "answer": "APR alati poput SemFix i SapFix mogu automatski ispraviti sintaktičke greške, kao što su izostavljene zagrade, zarezi ili pogrešno napisana imena varijabli. Oni koriste statičku analizu koda kako bi prepoznali nedostatke i umetnuli nedostajuće elemente, \r\npoput vitičaste zagrade u C++ funkciji.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 60,
  "fields": {
    "lecture_id": 6,
    "subject": 1,
    "question": "Koji su neki problemi kod automatskog ispravljanja programa? ",
    "answer": "Ponekad popravci nisu točni, program može raditi krivo nakon ispravka ili sustav ne može prepoznati sve greške.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 61,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Zašto učiti asemblerski jezik?",
    "answer": "- Pomaže razumijevanju rada procesora\\n- Brži od jezika višeg nivoa\\n- Koristan u kritičnim dijelovima koda za performanse\\n- Omogućuje pristup operacijama koje kompajleri ne koriste (npr. ROR, RRX)\\n- Koristi se za boot kod, drivere, kompajlere\\n- Potreban u aplikacijama osjetljivim na kašnjenje\\n- Bolje razumijevanje jezika višeg nivoa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 62,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Kako izgleda jednostavan C program i njegov ekvivalent u asemblerskom i binarnom kodu?",
    "answer": "C:\\nint main(void){ int a = 0; int b = 1; int c; c = a + b; return 0; }\\nAssembly:\\nmovs r1, #0x00\\nmovs r2, #0x01\\nadds r3, r1, r2\\nmovs r0, 0x00\\nbx lr\\nMachine code (hex):\\n2100\\n2201\\n188B\\n2000\\n4770",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 63,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Što je Program Counter (PC) i čemu služi?",
    "answer": "PC je registar koji sadrži adresu naredbe koja će se sljedeća dohvatiti iz memorije. Program se izvršava kroz tri faze: Fetch, Decode i Execute.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 64,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Koja je razlika između Von-Neumann i Harvard arhitekture?",
    "answer": "Von-Neumann: instrukcije i podaci pohranjeni u istoj memoriji\\nHarvard: instrukcije i podaci pohranjeni u odvojenim memorijama",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 65,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Kako izgleda proces izračuna sume elemenata niza u C-u i asemblerskom jeziku?",
    "answer": "C kod:\\nint a[10] = {1,...,10}; int total = 0; for (int i=0; i<10; i++) total += a[i];\\nAsembler (komentarirani):\\nmovs  r1, #0x00\\nldr   r2, =total_addr\\nstr   r1, [r2, #0x00]\\nmovs  r0, #0x00\\nb     check\\nloop:\\nldr   r1, =a_addr\\nldr   r1, [r1, r0, lsl #2]\\nldr   r2, =total_addr\\nldr   r2, [r2, #0x00]\\nadd   r1, r1, r2\\nldr   r2, =total_addr\\nstr   r1, [r2, #0x00]\\nadds  r0, r0, #1\\ncheck:\\ncmp   r0, #0x0a\\nblt   loop\\nnop\\nself:\\nb     self",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 66,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Koje ARM Cortex-M jezgre postoje i kojoj arhitekturi pripadaju?",
    "answer": "ARM Cortex-M0, M1, M0+, M23, M3, M4, M7, M33\\nPripadaju arhitekturama: ARMv6-M, ARMv7-M, ARMv7E-M, ARMv8-M",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 67,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Koji su osnovni registri u ARM Cortex-M procesorima?",
    "answer": "R0-R12: opći registri\\nR13: Stack Pointer\\nR14: Link Register\\nR15: Program Counter\\nSpecijalni registri: xPSR, BASEPRI, PRIMASK, FAULTMASK itd.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 68,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Koje su karakteristike Thumb-2 instrukcija?",
    "answer": "Thumb-2 koristi kombinaciju 16-bitnih i 32-bitnih instrukcija. Procesor uvijek dohvaća 4 bajta (ili dvije 16-bitne ili jednu 32-bitnu instrukciju).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 69,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Kako izgleda memorijska mapa podataka za niz i total?",
    "answer": "Primjer:\\na[0] = 0x00000001 na adresi 0x20000000\\na[1] = 0x00000002 na 0x20000004\\n...\\na[9] = 0x0000000A na 0x20000024\\ntotal = 0x00000000 na 0x20000028",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 70,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Gdje se mogu vidjeti teardowns uređaja s ARM čipovima?",
    "answer": "Izvori poput ifixit.com prikazuju teardown uređaja kao što su iPhone, Fitbit, Galaxy Gear, itd.",
    "link": "http://www.ifixit.com"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 71,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Čemu služe registri SP, LR i PC?",
    "answer": "- PC (Program Counter): sadrži adresu naredne instrukcije koja će se izvršiti\\n- LR (Link Register): sadrži adresu povratka iz subrutine (PC + 4)\\n- SP (Stack Pointer): pokazuje na vrh stoga i koristi se za spremanje podataka (npr. spremanje LR prije skoka u drugu subrutinu)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 72,
  "fields": {
    "lecture_id": 1,
    "subject": 2,
    "question": "Kako se i gdje u memoriju zapisuju dijelovi koda i podaci?",
    "answer": "- Kod (instrukcije): Flash memorija\\n- Globalne/statističke varijable: SRAM (segmenti .bss i .data)\\n- Lokalne varijable: Stack\\n- Dinamički alocirane varijable: Heap",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 73,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Koji su formati za prikaz brojeva?",
    "answer": "Decimalni, binarni, oktalni i heksadecimalni. Npr:\\nDecimal: 10\\nBinarni: 1010\\nOktalni: 012\\nHeksadecimalni: 0xA",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 74,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Koji su primjeri 'magijskih' 32-bitnih vrijednosti?",
    "answer": "0xDEADBEEF – Dead Beef\\n0xDEADC0DE – Dead Code\\n0xFACEB00C – Facebook\\n0x8BADF00D – Ate Bad Food\\nKoriste se za debugiranje i označavanje memorije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 75,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Kako se binarni broj 1011₂ pretvara u decimalni?",
    "answer": "1011₂ = 1×2³ + 0×2² + 1×2¹ + 1×2⁰ = 8 + 0 + 2 + 1 = 11₁₀",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 76,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Koji je raspon nesigurnih (unsigned) cijelih brojeva po veličini?",
    "answer": "Byte: 0 do 255\\nHalfword: 0 do 65,535\\nWord: 0 do 4,294,967,295\\nDouble-word: 0 do 18,446,744,073,709,551,615",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 77,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Što označava carry flag kod nesigurnih brojeva?",
    "answer": "Postavlja se kada zbrajanje rezultira prelaskom granice (npr. 28 + 6 u 5-bitnom sustavu prelazi granicu 31 → postavlja se carry).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 78,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Koji su načini za prikazivanje predznakih binarnih brojeva?",
    "answer": "1. Sign-and-Magnitude\\n2. One’s Complement\\n3. Two’s Complement (najčešći u modernim sustavima)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 79,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Kako funkcionira Two’s Complement metoda?",
    "answer": "Za negativan broj:\\n1. Inverzija bitova pozitivnog broja\\n2. Dodavanje 1\\nPrimjer: TC(3) = 0b00011 → invert = 11100 + 1 = 11101 = -3",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 80,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Koji je raspon signed cijelih brojeva?",
    "answer": "Signed Byte: -128 do +127\\nSigned Halfword: -32,768 do +32,767\\nSigned Word: -2,147,483,648 do +2,147,483,647\\nSigned Double-word: ±9.2×10¹⁸",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 81,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Kada dolazi do overflowa kod sabiranja predznakih brojeva?",
    "answer": "1. Kad se zbrajaju dva pozitivna broja, a rezultat je negativan\\n2. Kad se zbrajaju dva negativna broja, a rezultat je pozitivan\\nNe dolazi do overflowa kad su operandima različiti predznaci.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 82,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Zna li CPU je li broj signed ili unsigned?",
    "answer": "Ne. CPU postavlja carry i overflow zastavice, a softver odlučuje kako ih interpretirati.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 83,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Kako ASCII kod mapira znakove?",
    "answer": "ASCII koristi brojeve 0–127 za znakove. Npr:\\nA = 65 (0x41), a = 97 (0x61), ‘a’ – ‘A’ = 32",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 84,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Kako izgleda null-terminated string u memoriji?",
    "answer": "char str[] = “ARM Assembly” sadrži 13 bajtova:\\n12 slova + 1 NULL terminator (0x00).\\nZadnji znak mora biti ‘\\0’.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 85,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Kako funkcija `toUpper` pretvara string u velika slova?",
    "answer": "Koriste se dvije metode:\\n1. Dereferenciranjem pokazivača (*p)\\n2. Korištenjem indeksa (pStr[i])\\nAko je znak između 'a' i 'z', oduzme se 32.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 86,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Koji su rasponi za zapisivanje cijelih brojeva određenim brojem bita i primjer preljeva/podljeva?",
    "answer": "- 8-bitni bez predznaka: 0–255\\n- 8-bitni s predznakom: -128 do 127\\nPrimjer preljeva: 127 + 1 = -128\\nPrimjer podljeva: 0 - 1 = 255 (bez predznaka)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 87,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Što je proširenje predznaka (sign extension)?",
    "answer": "Proširenje manjeg tipa na veći uz zadržavanje predznaka. Ako MSB izvornog tipa (npr. 8-bitni broj) iznosi 1, svi dodatni bitovi u proširenom tipu postaju 1 (npr. 0xF4 → 0xFFFFFFF4)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 88,
  "fields": {
    "lecture_id": 2,
    "subject": 2,
    "question": "Koja je razlika između brojeva s i bez predznaka?",
    "answer": "- S predznakom koristi MSB za znak: 0 = pozitivan, 1 = negativan\\n- Bez predznaka: svi bitovi predstavljaju vrijednost",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 89,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Koje su glavne ARM Cortex obitelji i njihova namjena?",
    "answer": "Cortex-A: aplikacije i OS\\nCortex-R: real-time i pouzdanost\\nCortex-M: mikrokontroleri i niska cijena",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 90,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Koje registre sadrži ARM Cortex-M4?",
    "answer": "R0–R12: opći registri\\nR13: Stack pointer (MSP/PSP)\\nR14: Link register (LR)\\nR15: Program counter (PC)\\nSpecijalni: xPSR, BASEPRI, PRIMASK itd.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 91,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Kako procesor pristupa periferijskim registrima?",
    "answer": "Kroz memory-mapped I/O. Svaki periferijski registar ima adresu, a pristupa mu se naredbama load/store.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 92,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Što je Load-Modify-Store pristup?",
    "answer": "Učitavanje vrijednosti iz memorije u registar → modifikacija → spremanje natrag u memoriju. Čest uzorak pri prijevodu C koda u asembler.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 93,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Koje grupe instrukcija postoje u ARM ISA?",
    "answer": "- Aritmetičke i logičke (add, sub, mul, div)\\n- Premještanje podataka (load, store)\\n- Usporedba i skokovi (cmp, branch)\\n- Ostale (npr. wait, nop, barrier)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 94,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Koji je format ARM asemblerske instrukcije?",
    "answer": "label: mnemonic operand1, operand2, operand3 // komentar\\nPrimjer: add r0, r2, r3 // r0 = r2 + r3",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 95,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Koji su primjeri komentara u različitim asemblerskim alatima?",
    "answer": "GNU Assembler (gas): koristi ‘//’ ili ‘@’\\nARMasm: koristi ‘;’ kao komentar",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 96,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Kako izgleda program koji kopira string u ARM asembleru?",
    "answer": "ldr r0, =src_str\\nldr r1, =dst_str\\nloop:\\nldrb r2, [r0], #1\\nstrb r2, [r1], #1\\ncmp r2, #0\\nbne loop\\nstop:\\nb stop\\n.data\\nsrc_str: .asciz \\The source string!\\\"\\ndst_str: .space 20\"",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 97,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Koje direktive se koriste za definiranje podataka?",
    "answer": "- .byte, .hword, .word, .quad: različite veličine\\n- .ascii, .asciz: tekstualni podaci\\n- .space: memorija nula\\n- .fill: memorija s inicijaliziranim vrijednostima",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 98,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Čemu služe .equ i .req direktive?",
    "answer": ".equ: simboličko ime za konstantu (kao #define)\\n.req: simboličko ime za registar (npr. Dividend .req r6)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 99,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Čemu služe .balign i .align?",
    "answer": ".align: poravnanje instrukcija ili podataka (moguće nepouzdano)\\n.balign: sigurno poravnanje na zadanu granicu (npr. 4 ili 8 bajta)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 100,
  "fields": {
    "lecture_id": 3,
    "subject": 2,
    "question": "Čemu služi direktiva .include u asembleru?",
    "answer": ".include se koristi za uključivanje vanjskog datoteka (npr. sa simbolima definiranim kroz .equ). Omogućuje organiziran i ponovno upotrebljiv kod.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 101,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako se sabiraju dva cijela broja u ARM asembleru?",
    "answer": "add r2, r1, r0  // r2 = r1 + r0\\nVrijednosti: x u r0, y u r1, rezultat u r2",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 102,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako izgleda sabiranje vrijednosti preko pokazivača?",
    "answer": "ldr r3, [r0] // čita x\\nldr r4, [r1] // čita y\\nadd r5, r3, r4\\nstr r5, [r2] // piše z",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 103,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Koje su osnovne aritmetičke i logičke instrukcije u ARM-u?",
    "answer": "ADD, ADC, SUB, SBC, RSB, MUL, MLA, MLS, SDIV, UDIV\\nBitovne: AND, ORR, EOR, ORN, BIC, MVN, BFC, BFI",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 104,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako se koriste instrukcije za 64-bitno sabiranje?",
    "answer": "adds r4, r2, r0  // niži 32 bita\\nadc r5, r3, r1  // viši 32 bita s prijenosom",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 105,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Što su PSR i NZCV zastavice?",
    "answer": "PSR sadrži informacije o rezultatu instrukcija.\\nNZCV: Negative, Zero, Carry, Overflow\\nSufiks 'S' (npr. ADDS) ažurira zastavice.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 106,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako se koristi SSAT i USAT?",
    "answer": "ssat r2, #11, r1 // saturacija na -1024 do +1023\\nusat r2, #11, r3 // saturacija na 0 do 2047",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 107,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Što rade REV, RBIT, REV16 i REVSH instrukcije?",
    "answer": "RBIT: obrće bitove\\nREV: obrće bajtove\\nREV16: obrće bajtove u polu riječi\\nREVSH: obrće i proširuje znak",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 108,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako se proširuju znak i nula u registrima?",
    "answer": "SXTB/SXTH: proširenje sa znakom\\nUXTB/UXTH: proširenje nulom\\nPrimjer: sxtb r1, r0",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 109,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako se koristi MOVT i MOVW za učitavanje 32-bitne konstante?",
    "answer": "movw r0, #0x4321\\nmovt r0, #0x8765  // r0 = 0x87654321",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 110,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako postaviti bit u registru?",
    "answer": "movs r4, #1\\nlsls r4, r4, #5\\norrs r0, r0, r4 // ili: orrs r0, r0, r4, lsl #5",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 111,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako se briše bit u registru?",
    "answer": "movs r4, #1\\nlsls r4, r4, #5\\nmvns r4, r4\\nands r0, r0, r4 // ili: bics r0, r0, r4, lsl #5",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 112,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako se invertira (toggle) bit?",
    "answer": "movs r4, #1\\neors r0, r0, r4, lsl #5 // ekskluzivni OR s pomakom",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 113,
  "fields": {
    "lecture_id": 4,
    "subject": 2,
    "question": "Kako se koriste maske za upravljanje bitovima?",
    "answer": "- Data &= Mask // zadrži maskirane\\n- Data &= ~Mask // izbriši maskirane\\n- Data |= Mask // postavi maskirane\\n- Data ^= Mask // obrni maskirane",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 114,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Kako se podaci organiziraju u memoriji?",
    "answer": "8 bita = 1 bajt; 16 bita = 2 bajta = 1 halfword; 32 bita = 4 bajta = 1 word",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 115,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Što znači da je memorija adresabilna po bajtovima?",
    "answer": "Svaka memorijska adresa referencira jedan bajt, a ne riječ ili halfword.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 116,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Možemo li pohraniti word na bilo koju adresu memorije?",
    "answer": "Ne, word se može pohraniti samo na adresu djeljivu s 4.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 117,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Možemo li pohraniti halfword na bilo koju adresu memorije?",
    "answer": "Ne, halfword se može pohraniti samo na adresu djeljivu s 2.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 118,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koja je razlika između Big Endian i Little Endian?",
    "answer": "Kod Little Endian, LSB je na najnižoj adresi, dok je kod Big Endian MSB na najnižoj adresi.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 119,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koji registar sadrži adresu, a koji podatke u LDR instrukciji?",
    "answer": "rs sadrži adresu, rt sadrži podatke dohvaćene iz memorije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 120,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koji je efekt naredbe `ldr r1, [r0]` ako je r0 = 0x08200004?",
    "answer": "r1 = sadržaj riječi na adresi 0x08200004.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 121,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koji je efekt naredbe `str r1, [r0]` ako je r0 = 0x08200004?",
    "answer": "Sadržaj registra r1 se pohranjuje na adresu 0x08200004.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 122,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Kako učitati signed byte i signed halfword u registar?",
    "answer": "Koriste se `LDRSB` za signed byte i `LDRSH` za signed halfword.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 123,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Što znači sign extension?",
    "answer": "Proširenje znaka omogućuje aritmetiku sa znakom nakon učitavanja signed byte/halfword u 32-bitni registar.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 124,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Što znači adresiranje pomoću registra kao offseta?",
    "answer": "Adresa se izračunava kao baza + sadržaj registra koji sadrži offset, npr. `ldr r0, [r1, r2]`. ",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 125,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koje su tri vrste adresiranja s neposrednim offsetom?",
    "answer": "Pre-index (`ldr r1, [r0, #4]`), Post-index (`ldr r1, [r0], #4`), Pre-index with update (`ldr r1, [r0, #4]!`)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 126,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koja je razlika između pre-index i post-index adresiranja?",
    "answer": "Pre-index koristi adresu r0 + offset bez mijenjanja r0, dok post-index koristi r0, ali ažurira r0 nakon učitavanja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 127,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Što znači `ldr r1, [r0, #4]!`?",
    "answer": "Učitava vrijednost s adrese r0 + 4 u r1 i ažurira r0 na r0 + 4.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 128,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koje su instrukcije za učitavanje/spremanje više registara?",
    "answer": "STMxx i LDMxx, gdje xx može biti IA, IB, DA, DB.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 129,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Što znači STMIA?",
    "answer": "STM s Increment After – adresa se povećava za 4 nakon pohrane riječi.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 130,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Što znači LDMIA?",
    "answer": "LDM s Increment After – adresa se povećava za 4 nakon učitavanja riječi.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 131,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koja su sinonimna imena za STMIA i LDMIA?",
    "answer": "STMIA = STMEA (Empty Ascending), LDMIA = LDMFD (Full Descending)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 132,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Memorijska mapa korištenog mikrokontrolera?",
    "answer": "Za detalje pogledaj: slajd 38 iz 1. prezentacije i slajd 42 iz 5. prezentacije",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 133,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Što je endianness?",
    "answer": "Redoslijed pohrane bajtova u memoriji:\\n- Little endian: LSB se pohranjuje na manju adresu\\n- Big endian: MSB se pohranjuje na manju adresu",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 134,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Koji su načini adresiranja u asembleru?",
    "answer": "- Immediate: LDR R0, =0x1000\\n- Register: MOV R0, R1\\n- Register indirect: LDR R0, [R1]\\n- Register offset: LDR R0, [R1, R2]\\n- Immediate offset: LDR R0, [R1, #8]\\n- Pre-indexed: LDR R0, [R1, #4]!\\n- Post-indexed: LDR R0, [R1], #4",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 135,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Kako se koriste STMxx instrukcije za spremanje više registara?",
    "answer": "Primjeri:\\n- STMDB SP!, {R0–R3} ; Decrement Before\\n- STMIA SP!, {R0–R3} ; Increment After\\nUčitavanje više registara:\\n- LDMIA SP!, {R0–R3}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 136,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Kako se implementira Full Descending stack u memoriji?",
    "answer": "Koristi STMDB SP!, {reg_list} za spremanje\\nPOP: LDMIA SP!, {reg_list}\\nPrimjer: STMDB SP!, {R4–R6}; LDMIA SP!, {R4–R6}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 137,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Kako se implementira Empty Descending stack u memoriji?",
    "answer": "Koristi STMFD (ekvivalentno STMDB) i LDMFD (ekvivalentno LDMIA)\\nSP pokazuje na sljedeći slobodni prostor",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 138,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Kako se implementira Full Ascending stack u memoriji?",
    "answer": "Koristi STMIB SP!, {reg_list} za spremanje\\nPOP: LDMDB SP!, {reg_list}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 139,
  "fields": {
    "lecture_id": 5,
    "subject": 2,
    "question": "Kako se implementira Empty Ascending stack u memoriji?",
    "answer": "Koristi STMFA (ekvivalentno STMIB) i LDMFA (ekvivalentno LDMDB) – rijetko korišteno",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 140,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Koje su tri osnovne kontrolne strukture u programiranju?",
    "answer": "Sekvenca, selekcija (if-then-else) i petlja (while, for)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 141,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Koje bitove sadrži statusni registar za uvjetno grananje?",
    "answer": "N (negative), Z (zero), C (carry), V (overflow)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 142,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Kako ažurirati statusne zastavice (flags)?",
    "answer": "Dodavanjem 'S' sufiksa instrukciji (npr. adds), ili korištenjem CMP, CMN, TST, TEQ instrukcija koje ažuriraju zastavice bez zapisivanja rezultata.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 143,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Što radi instrukcija `B label`?",
    "answer": "Bezuslovni skok na adresu označenu labelom.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 144,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Što radi instrukcija `BL label`?",
    "answer": "Skok na label s pohranom adrese sljedeće instrukcije u registar `r14` (link register).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 145,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Koja je razlika između `BX Rm` i `BLX Rm`?",
    "answer": "`BX Rm` vrši skok na adresu iz registra Rm, dok `BLX Rm` uz to pohranjuje adresu povratka u `r14`.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 146,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Koje su najčešće korištene uvjetne instrukcije grananja?",
    "answer": "BEQ, BNE, BGE, BLT, BGT, BLE, BCS/BHS, BCC/BLO, BMI, BPL, BVS, BVC",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 147,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Kako razlikujemo usporedbe s predznakom i bez predznaka u grananju?",
    "answer": "Koriste se različiti sufiksi: npr. `BLT` za signed <, `BLO` za unsigned <",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 148,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Koja instrukcija se koristi za if-then bez else u asemblerskom kodu?",
    "answer": "Obično `cmp` + `bge` za preskakanje `then` dijela ako uvjet nije zadovoljen, ili se koristi `it` blok npr. `it lt",
    "link": "rsblt r1, r1, #0`"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 149,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Kako implementirati if-then-else strukturu u asembleru?",
    "answer": "Korištenjem `cmp` + `bne` za skok na `else`, `mov` za then/else dijelove i `b` za preskok `else` dijela",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 150,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Kako izgleda implementacija for petlje u asembleru?",
    "answer": "Korištenjem inicijalizacije, usporedbe s brojačem (cmp), uvjetnog skoka (blt, bge) i inkrementa unutar tijela petlje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 151,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Čemu služi IT instrukcija u Thumb-2 arhitekturi?",
    "answer": "Omogućuje uvjetnu izvršbu do 4 instrukcije na osnovu jedne usporedbe bez korištenja grana.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 152,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Kako koristiti IT blok s više THEN i ELSE instrukcija?",
    "answer": "Kombinacijom sufiksa: `itte ne`, `itt eq`, itd. koji označavaju redoslijed THEN i ELSE uvjetno izvršavanih naredbi.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 153,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Koja je razlika između `CBZ` i `BEQ`?",
    "answer": "CBZ uspoređuje registar s nulom i vrši skok ako je nula, dok `cmp rn, #0` + `beq` radi isto, ali mijenja statusne zastavice.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 154,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Kako implementirati break u asembleru?",
    "answer": "Upotrebom CBZ/CBNZ za uvjetni skok izvan petlje kada je ispunjen uvjet prekida.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 155,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Što su condition codes i kako se koriste za brojeve s i bez predznaka?",
    "answer": "Zastavice:\\n- N (Negative), Z (Zero), C (Carry), V (Overflow)\\nZa s predznakom koristi se V i N\\nZa bez predznaka koristi se C i Z\\nPrimjer: BGT, BLE, BCS, BCC itd.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 156,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Kako implementirati petlju for (int i=10",
    "answer": " i>0",
    "link": "i--) u asembleru?"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 157,
  "fields": {
    "lecture_id": 6,
    "subject": 2,
    "question": "Što rade CMP, TST i TEQ instrukcije?",
    "answer": "- CMP R1, R2: oduzima R2 od R1 i postavlja zastavice\\n- TST R1, R2: logički AND, postavlja Z ako je rezultat nula\\n- TEQ R1, R2: logički XOR, postavlja Z ako su identični",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 158,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Koje su osnovne strukture kontrole toka u programiranju?",
    "answer": "Sekvenca, selekcija (if-then-else), petlja (while, for)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 159,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Zašto je 'goto' problematičan u programiranju?",
    "answer": "Prekomjerno korištenje 'goto' vodi do tzv. spaghetti koda koji je teško održavati i razumjeti",
    "link": "https://en.wikipedia.org/wiki/Spaghetti_code"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 160,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Zašto se asemblerski jezik ne smatra strukturiranim programiranjem?",
    "answer": "Jer nema direktnu podršku za selekciju i petlje, grane su ekvivalentne 'goto' naredbama u C-u.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 161,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Koja strategija dizajna softvera se preporučuje u asembleru?",
    "answer": "Top-down dizajn: razbijanje zadataka na manje dok ne postanu jednostavni za rješavanje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 162,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Što je Armstrongov broj?",
    "answer": "Pozitivan broj za koji vrijedi da je jednak zbroju n-tih potencija svojih znamenki, gdje je n broj znamenki. (npr. 153 = 1³ + 5³ + 3³)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 163,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Kako se može smanjiti broj korištenih registara u asemblerskom programu?",
    "answer": "Ponovnim korištenjem istih registara za više varijabli kada nisu istovremeno potrebni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 164,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Kako izgleda asemblerska implementacija faktorske petlje za n = 5?",
    "answer": "Registri: r0 = rezultat, r1 = n, r2 = brojač i; Petlja: `mul r0, r2, r0; add r2, r2, 1; cmp r2, r1; bgt stop`;",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 165,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Kako brojati jedinice u 32-bitnoj riječi koristeći asembler?",
    "answer": "Kombinacijom `LSR`, `LSL`, i `ADC` instrukcija da se prebroje bitovi koji su 1 pomicanjem i sabiranjem s prenesenim bitom.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 166,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Kako pronaći maksimum u nizu i njegov indeks u asembleru?",
    "answer": "Uspoređivati svaki element s trenutnim maksimumom, ažurirati maksimalnu vrijednost i indeks kad je pronađen veći element. Koriste se `cmp`, `itt gt`, `movgt` instrukcije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 167,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Kako se iz potprograma poziva drugi potprogram i što sadrži LR?",
    "answer": "Prije poziva druge funkcije, LR se mora spremiti na stack (push {lr}) i vratiti prije izlaska (pop {pc} ili pop {lr}); inače se gubi adresa povratka u originalnu funkciju",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 168,
  "fields": {
    "lecture_id": 7,
    "subject": 2,
    "question": "Kako se argumenti funkcije prenose prema APCS-u?",
    "answer": "Prva četiri argumenta: r0–r3\\nPeti i ostali: stack\\nPovratna vrijednost: r0\\nRegistre r4–r11 i SP treba sačuvati u subrutini ako se koriste",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 169,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako se poziva potprogram (subroutine) u ARM asemblerskom jeziku?",
    "answer": "Pomoću naredbe BL (Branch with Link), koja skokne na adresu potprograma i u LR (Link Register) upisuje adresu povratka",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 170,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako se vraća iz potprograma u ARM arhitekturi?",
    "answer": "Naredbom BX LR, koja vraća izvršavanje na adresu spremljenu u LR (Link Register)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 171,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako se prosljeđuju parametri potprogramu u ARM-u?",
    "answer": "Prva četiri parametra (8-, 16-, 32-bitni) šalju se putem registara R0–R3, a dodatni parametri se stavljaju na stog (stack)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 172,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako ARM potprogram vraća vrijednost?",
    "answer": "Vrijednost se vraća putem registra R0. Za 64-bitne vrijednosti koristi se R0:R1, a za 128-bitne R0–R3",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 173,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Što sadrži Link Register (LR) tijekom izvođenja potprograma?",
    "answer": "Sadrži adresu na koju se treba vratiti nakon završetka potprograma (PC + 4)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 174,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako izgleda C funkcija i njezin asemblerski ekvivalent koji zbraja četiri parametra?",
    "answer": "C: int32_t sum(uint8_t a8, int8_t b8, uint16_t c16, uint16_t d16);\r\nASM:\\nmovs r0, #1\\nmovs r1, #2\\nmovs r2, #3\\nmovs r3, #4\\nbl sum\\nsum:\\n add r0, r0, r1\\n add r0, r0, r2\\n add r0, r0, r3\\n bx lr",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 175,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako se pozivaju potprogrami s više od četiri argumenta u ARM-u?",
    "answer": "Prva četiri argumenta idu u R0–R3, a preostali se stavljaju na stog i učitavaju iz njega u potprogramu pomoću naredbi poput LDRD",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 176,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Koja je razlika između callee-saved i caller-saved registara?",
    "answer": "Caller-saved: R0–R3, R12 – pozivatelj mora sačuvati ako ih želi očuvati\\nCallee-saved: R4–R11 – potprogram ih mora vratiti ako ih koristi",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 177,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako C funkcija može pozvati asemblersku funkciju?",
    "answer": "Ako asemblerska funkcija poštuje ARM Procedure Call Standard (APCS), moguće ju je pozvati iz C koda koristeći extern deklaraciju.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 178,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Što znači da je najmanje značajan bit u LR registru postavljen na 1?",
    "answer": "To označava da je u upotrebi THUMB mod (ARM Cortex-M podržava samo THUMB instrukcije)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 179,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako se zbrajaju dva 64-bitna broja u ARM-u?",
    "answer": "Donje 32 bita se zbrajaju s ADDS, a gornji s ADC:\\nadds r0, r2, r0\\nadc r1, r3, r1\\nbx lr",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 180,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako izgleda implementacija funkcije SSQ(x, y) = x² + y² u ARM asembleru?",
    "answer": "SSQ:\\n mul r2, r0, r0\\n mul r3, r1, r1\\n add r2, r2, r3\\n mov r0, r2\\n bx lr",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 181,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Što je stog (stack) i za što se koristi u ARM arhitekturi?",
    "answer": "Stog je LIFO memorijska struktura. Koristi se za:\\n- spremanje registara pri ulasku u potprogram\\n- pohranu lokalnih varijabli\\n- prosljeđivanje dodatnih argumenata\\n- spremanje registara pri prekidima",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 182,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kakav tip stoga koristi ARM Cortex-M arhitektura?",
    "answer": "ARM Cortex-M koristi pun opadajući stog (full descending stack), što znači da SP pokazuje na zadnji spremljeni podatak i da se stog smanjuje prema nižim adresama.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 183,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako se spremaju i vraćaju registri pomoću stoga?",
    "answer": "Za spremanje: PUSH {reg_list} – SP se smanjuje, vrijednosti se pohranjuju\\nZa vraćanje: POP {reg_list} – SP se povećava, vrijednosti se vraćaju u registre",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 184,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Koji registri se mogu PUSH/POP naredbama?",
    "answer": "PUSH: r0–r12, LR\\nPOP: r0–r12, LR, PC",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 185,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Koja je razlika između caller-saved i callee-saved registara?",
    "answer": "Caller-saved: R0–R3, R9, R12 – pozivatelj ih mora sačuvati\\nCallee-saved: R4–R11 – potprogram mora vratiti izvorne vrijednosti ako ih koristi",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 186,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako sačuvati runtime okruženje unutar potprograma?",
    "answer": "Potprogram treba spremiti callee-saved registre koje koristi:\\npush {r4, lr} ... pop {r4, lr} ili pop {r4, pc}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 187,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Što je problem ako potprogram foo poziva drugi potprogram bar, a koristi LR registar?",
    "answer": "Ako foo ne spremi LR prije poziva bara, adresa povratka se prepisuje. Rješenje: spremiti i LR:\\npush {r4, lr} ... bl bar ... pop {r4, lr}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 188,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako izgledaju instrukcije za zamjenu vrijednosti registara R1 i R2 pomoću stoga?",
    "answer": "push {r1}\\npush {r2}\\npop {r1}\\npop {r2}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 189,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Zašto naredba push {r1, r2}",
    "answer": " pop {r2, r1} ne zamjenjuje vrijednosti R1 i R2?",
    "link": "Zbog načina pohrane – redoslijed pop naredbi nije isti kao redoslijed push, pa se vrijednosti ne zamjenjuju. Rješenje je pop {r2}; pop {r1}"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 190,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako se prosljeđuje više od četiri argumenta funkciji?",
    "answer": "Prva četiri idu u R0–R3, a ostali se stavljaju na stog:\\npush {r4–r7}\\n... bl funkcija\\n... pop {r4–r7}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 191,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako izgleda asemblerska funkcija koja prima 8 argumenata i vraća njihov zbroj?",
    "answer": "sum:\\npush {r5, r6, lr}\\nadd r0, r0, r1\\nadd r0, r0, r2\\nadd r0, r0, r3\\nldrd r5, r6, [sp, #12]\\nadd r0, r0, r5\\nadd r0, r0, r6\\nldrd r5, r6, [sp, #20]\\nadd r0, r0, r5\\nadd r0, r0, r6\\npop {r5, r6, pc}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 192,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Što znači da je stog pun (full) i opadajući (descending)?",
    "answer": "Pun: SP pokazuje na zadnji pohranjeni element\\nOpadajući: stog raste prema nižim adresama",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 193,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako se inicijalizira stog u ARM-u?",
    "answer": "Stack se inicijalizira u startup.s datoteci postavljanjem SP na odgovarajuću adresu memorije (npr. 0x20018000)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 194,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Tko je zadužen za čuvanje vrijednosti registara prilikom poziva potprograma?",
    "answer": "- Caller: mora sačuvati R0–R3, R12 ako mu trebaju kasnije\\n- Callee: mora sačuvati R4–R11 i SP ako ih koristi",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 195,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako iz C-a pozvati asemblersku funkciju s 5 argumenata?",
    "answer": "Deklaracija u C: extern int32_t sum5(int32_t a1, ..., int32_t a5);\\nPoziv: sum5(a, b, c, d, e);\\nAsembler: sum5: .global sum5; koristi r0–r3, a peti argument se uzima sa stoga",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 196,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako iz asemblera pozvati C funkciju s 5 argumenata?",
    "answer": "C: int32_t calc(int32_t a, ..., int32_t e);\\nAsembler:\\n.global call_from_asm\\n.extern calc\\nmov r0, #1 ... mov r3, #4\\nmov r4, #5\\npush {r4}\\nbl calc\\npop {r4}",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 197,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako u C-u koristiti varijable definirane u asembleru?",
    "answer": "Asembler:\\n.global asm_var\\nasm_var: .word 1234\\nC:\\nextern uint32_t asm_var;",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 198,
  "fields": {
    "lecture_id": 8,
    "subject": 2,
    "question": "Kako u asembleru koristiti varijable definirane u C-u?",
    "answer": "C:\\nuint32_t c_var = 100;\\nAsembler:\\n.extern c_var\\nLDR R0, =c_var\\nLDR R1, [R0]",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 199,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Što je RCC i čemu služi?",
    "answer": "RCC (Reset and Clock Control) upravlja sistemskim i perifernim taktovima. Omogućuje konfiguraciju izvora takta i njihove aktivacije kako bi se zadovoljili zahtjevi za potrošnjom energije i točnošću.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 200,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Koji su interni izvori takta dostupni na STM32?",
    "answer": "- HSI16: visoko-brzi interni 16 MHz RC oscilator\\n- MSI: višebrzinski interni RC oscilator (100 kHz – 48 MHz)\\n- LSI: nisko-brzi interni 32 kHz RC oscilator",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 201,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Koji su eksterni izvori takta dostupni na STM32?",
    "answer": "- HSE: visoko-brzi vanjski oscilator (4–48 MHz) s CSS-om\\n- LSE: nisko-brzi vanjski oscilator (32.768 kHz) s CSS-om",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 202,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Što su PLL-ovi i čemu služe?",
    "answer": "Postoje tri PLL-a s neovisnim izlazima. Koriste jedan od dostupnih izvora takta za generiranje viših frekvencija potrebnih za sistemski rad ili periferije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 203,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Kako utječe frekvencija takta na performanse i potrošnju energije?",
    "answer": "- Viša frekvencija → bolje performanse\\n- Niža frekvencija → manja potrošnja\\n- MSI ima manju potrošnju, ali i manju preciznost od HSI16",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 204,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Koji je zadani izvor sistemskog takta nakon resetiranja?",
    "answer": "MSI je zadani izvor sistemskog takta, s frekvencijom od 4 MHz. HSI16 je inicijalno isključen.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 205,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Kako se može konfigurirati sistemski takt?",
    "answer": "Postoje tri pristupa:\\n- Lako: CubeMX alat\\n- Teže: HAL / LL biblioteke\\n- Najteže: ručna konfiguracija registara u C-u ili asemblerski",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 206,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Koji su osnovni koraci za konfiguraciju HSI16 kao izvora PLL i sistemskog takta na 80 MHz?",
    "answer": "1. Omogući HSI\\n2. Čekaj dok nije spreman\\n3. Postavi PLL parametre\\n4. Omogući PLL\\n5. Omogući PLLR izlaz\\n6. Čekaj dok PLL ne bude spreman\\n7. Povećaj Flash latenciju na 4 WS\\n8. Postavi PLL kao sistemski takt\\n9. Onemogući MSI",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 207,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Koji alati/dokumenti su nužni za konfiguraciju sistemskog takta?",
    "answer": "Referentni priručnik (Reference Manual) – polazište i završna točka za razumijevanje registara i konfiguracije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 208,
  "fields": {
    "lecture_id": 9,
    "subject": 2,
    "question": "Koji su interni izvori clocka i kako se konfiguriraju?",
    "answer": "- HSI16 (16 MHz), MSI (100 kHz – 48 MHz), LSI (32 kHz)\\n- PLL: koristi jedan od njih za generaciju viših frekvencija\\nKonfiguracija: omogućiti izvor, čekati spremnost, postaviti PLL, prebaciti sistemski takt",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 209,
  "fields": {
    "lecture_id": 1,
    "subject": 3,
    "question": "Što je operacijski sustav",
    "answer": "Program koji se stalno izvršava u računalu, jezgra operacijskog sustava. Ostalo su sistemski programi, aplikacije i dr.",
    "link": "https://www.youtube.com/watch?v=pVzRTmdd9j0"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 210,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što je sklopovlje računala i kako je povezano s operacijskim sustavom?",
    "answer": "Sklopovlje računala obuhvaća komponente kao što su procesor (CPU), memorija, I/O moduli (kontroleri za ulazno-izlazne uređaje) i sabirnice. Operacijski sustav koristi ove komponente za izvršavanje zadataka – upravlja memorijom, procesima i uređajima putem drajvera i kontrolera. OS je most između korisničkih aplikacija i sklopovlja.",
    "link": "https://blog.payrollschedule.net/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 211,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Koji su osnovni koraci u izvršavanju naredbe od strane CPU-a?",
    "answer": " CPU izvršava naredbe kroz ciklus koji uključuje: dobavljanje naredbe (fetch), dekodiranje naredbe (decode), dobavljanje operanda, izvršavanje (execute) i spremanje rezultata (store). Taj proces omogućuje sekvencijalno izvođenje instrukcija.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 212,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Koji su glavni registri u CPU-u i čemu služe?",
    "answer": "Glavni registri uključuju: Program Counter(PC) koji sadrži adresu sljedeće instrukcije, Instrukcijski register (IR) koji drži trenutno izvršavanu naredbu, Program Status Word (PSW) što su statusni bitovi za prekide, privilegije itd. i Dana i Address registri koji se koriste za operaciju s podacima i adresama",
    "link": "https://www.geeksforgeeks.org/what-is-register-digital-electronics/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 213,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Kako funkcioniraju I/O operacije u računalu?",
    "answer": "I/O operacije se odvijaju pomoću drajvera (softverska komponenta) i I/O kontrolera (hardverska komponenta). Podaci putuju između CPU-a i vanjskih uređaja, pri čemu se koriste registarske memorije (buffere) i različite linije (kontrolne, adresne, podatkovne).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 214,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što su prekidi (interrupts) i čemu služe?",
    "answer": "Prekidi omogućuju I/O uređajima da prekinu trenutni CPU zadatak kada završe operaciju, signalizirajući potrebu za obradom. CPU tada poziva odgovarajući prekidni program (ISR) i nakon obrade nastavlja s izvornim zadatkom. Time se CPU-ova učinkovitost značajno povećava.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 215,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što je Interrupt Vector Table (IVT) i koja je njena uloga?",
    "answer": "IVT je tablica u memoriji koja sadrži adrese svih prekidnih rutina (ISR). Svaki tip prekida je povezan s odgovarajućom adresom funkcije. Prije uključivanja prekida, OS mora inicijalizirati ovu tablicu.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 216,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Koje su vrste prekida u računalu?",
    "answer": "Postoje različite vrste prekida: I/O prekidi (npr. završetak ispisa), Programski izuzeci (npr. ilegalne instrukcije), timer prekidi, hardverske greške, softverski prekidi, ...",
    "link": "https://www.geeksforgeeks.org/interrupts/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 217,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što je Direct Memory Access (DMA)?",
    "answer": "DMA omogućuje I/O uređajima da izravno prenose podatke u memoriju bez uključivanja CPU-a u svaki prijenosni ciklus. CPU samo inicijalizira i završava proces, a time se CPU rasterećuje i povećava se ukupna brzina sustava.",
    "link": "https://www.youtube.com/watch?v=M16l_ymlfcs"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 218,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Koji su tipovi memorije u računalima?",
    "answer": "Tipovi memorije uključuju:Elektronske (RAM, ROM, EEPROM, Flash),Optičke (CD, DVD),Magnetske (diskovi, trake),Memorija u oblaku (npr. Dropbox),Cache memorija (brza međumemorija između CPU i RAM-a).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 219,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što je cache i kako funkcionira?",
    "answer": "Cache je brza memorija koja koristi princip lokalnosti – čuvanje često korištenih podataka blizu procesora. Ako se podaci nalaze u cacheu (cache hit), pristup je brz, dok u suprotnom (cache miss) podatak mora biti dohvaćen iz sporije memorije.",
    "link": "https://www.bing.com/search?qs=UT&pq=what+is+cache+memo&sk=CSYN1&sc=15-18&pglt=425&q=what+is+cache+memory&cvid=1856a3afbfc545ccab5871c6170aa704&gs_lcrp=EgRlZGdlKgcIABAAGPkHMgcIABAAGPkHMgYIARBFGDkyBggCEAAYQDIGCAMQABhAMgYIBBAAGEAyBggFEAAYQDIGCAYQABhAMgYIBxAAGEAyBggIEAAYQNIBCTEwMDEzajBqMagCCLACAQ&FORM=ANNTA1&PC=U531"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 220,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Koja je razlika između SSD-a i tvrdog diska (HDD)?",
    "answer": "SSD-ovi su brži, lakši, tiši, otporniji i troše manje energije. Međutim, imaju višu cijenu, manji kapacitet i ograničen broj ciklusa pisanja. HDD-ovi su jeftiniji s većim kapacitetom, ali sporiji.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 221,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Kako su se operacijski sustavi razvijali kroz povijest?",
    "answer": "Evolucija OS-a uključuje:Serijsko izvršavanje bez OS-a, Jednostavni batch sustavi – s monitorom koji izvršava niz poslova,Multiprogramirani batch sustavi – podrška za više programa u memoriji,Time-sharing sustavi – više korisnika koristi sustav interaktivno.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 222,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što je multiprogramiranje i koje su njegove prednosti?",
    "answer": " Multiprogramiranje omogućuje više programa da istovremeno budu u memoriji. Kada jedan čeka na I/O, drugi se može izvršavati. To povećava iskoristivost CPU-a i smanjuje prosječno vrijeme odziva.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 223,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što su Time – sharing sustavi?",
    "answer": "Sustavi gdje više korisnika (svaki na svom terminalu) mogu istovremeno koristiti sustav. Naglašava se interaktivnost gdje se više privilegira vrijeme odziva nego iskoristivost procesora",
    "link": "https://www.geeksforgeeks.org/time-sharing-operating-system/#:~:text=Time-sharing%20is%20a%20logical%20extension%20of%20multiprogramming.%20The,system%20allows%20multiple%20users%20to%20share%20computers%20simultaneously."
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 224,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Koje osnovne usluge pruža operacijski sustav?",
    "answer": "Operacijski sustav pruža sljedeće osnovne usluge: upravljanje procesima, memorijom, sekundarnom memorijom, I/O sustavom, datotekama, zaštitom, umrežavanjem te dodatne usluge poput detekcije pogrešaka i dodjele resursa.",
    "link": "https://www.geeksforgeeks.org/functions-of-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 225,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Što je proces i kako OS upravlja procesima?",
    "answer": "Proces je program u izvođenju. OS upravlja stvaranjem, izvršavanjem, zaustavljanjem i uništavanjem procesa, sinkronizacijom među njima, komunikacijom i izbjegavanjem zastoja (deadlocka).",
    "link": "https://www.geeksforgeeks.org/process-management-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 226,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Kako OS upravlja memorijom?",
    "answer": "OS prati koji dio memorije koristi koji proces, odlučuje koje procese smjestiti gdje i kada, te alocira i dealocira memoriju prema potrebi.",
    "link": "https://www.tutorialspoint.com/operating_system/os_memory_management.htm"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 227,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Zašto je potrebna sekundarna memorija i kako OS upravlja njome?",
    "answer": "Sekundarna memorija (npr. diskovi) koristi se jer glavna memorija nije postojana i ima ograničen kapacitet. OS upravlja logičkim formatiranjem, particioniranjem, alokacijom prostora i rasporedom operacija nad diskom.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 228,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Što je I/O sustav i koja je njegova uloga?",
    "answer": "I/O sustav omogućuje korisniku i programima rad s vanjskim uređajima. Upravljanjem bufferima, cacheom i spoolingom, I/O sustav prikriva složenost hardvera i koristi device drivere za komunikaciju s uređajima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 229,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Kako operacijski sustav upravlja datotekama?",
    "answer": "OS omogućuje kreiranje, brisanje, čitanje, pisanje i organizaciju datoteka i direktorija. Također osigurava pristupne kontrole i hijerarhijsku organizaciju.",
    "link": "https://www.tutorialspoint.com/operating_system/os_file_management.htm"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 230,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": " Koja je razlika između zaštite i sigurnosti u OS-u?",
    "answer": "Zaštita se odnosi na kontrolu pristupa procesima i korisnicima, dok se sigurnost odnosi na obranu od neautoriziranih unutarnjih i vanjskih napada.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 231,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Kako OS podržava umreženje?",
    "answer": "OS omogućuje razmjenu informacija među korisnicima i programima na lokalnim i udaljenim računalima, te pristup mrežnim resursima i internetu.",
    "link": "https://www.tutorialspoint.com/operating_system/os_networking.htm"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 232,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Što su korisnička sučelja u OS-u?",
    "answer": "Korisnička sučelja omogućuju interakciju korisnika s OS-om. CLI (Command Line Interface) koristi se za tekstualni unos naredbi, dok GUI (Graphical User Interface) koristi vizualne elemente poput ikona i prozora.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 233,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Što su sistemski programi?",
    "answer": "Sistemski programi omogućuju korisnicima manipulaciju datotekama, dobivanje informacija o sustavu, razvoj i izvođenje programa, komunikaciju, te pristup sustavskim funkcijama.",
    "link": "https://www.javatpoint.com/system-programs"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 234,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Što su sistemski pozivi i koja je njihova uloga?",
    "answer": "Sistemski pozivi su posrednici između korisničkog programa i OS-a. Omogućuju programima pristup funkcijama OS-a poput otvaranja datoteka, stvaranja procesa itd. Obično se pozivaju preko API-ja.",
    "link": "https://www.geeksforgeeks.org/system-calls-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 235,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Koji su primjeri sistemskih poziva u radu s datotekama?",
    "answer": "Tipični sistemski pozivi u radu s datotekama uključuju: open, read, write, close. Oni omogućuju otvaranje, čitanje i pisanje u datoteke te njihovo zatvaranje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 236,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Koji su osnovni modeli strukture OS-a?",
    "answer": "Postoje tri osnovna modela: monolitni (sve u jednom), slojeviti (funkcije podijeljene po slojevima) i mikrojezgreni (samo osnovne funkcije u kernelu, ostalo u user space-u).",
    "link": "https://www.studytonight.com/operating-system/structure-of-operating-system"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 237,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Što je proces i kako se razlikuje od programa?",
    "answer": "Proces je aktivna instanca programa koji se izvršava, dok je program pasivan skup instrukcija. Proces uključuje kontekst, memorijske resurse, stanje i druge atribute.",
    "link": "https://www.youtube.com/watch?v=vLwMl9qK4T8"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 238,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Koji su dijelovi memorijskog prostora procesa?",
    "answer": "Memorija procesa sastoji se od: tekstualnog dijela (kod), podatkovnog dijela (globalne varijable), stoga (lokalne varijable, parametri funkcija) i hrpe (dinamički alocirana memorija).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 239,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Kako se procesi pokreću u Unixu i Windowsima?",
    "answer": "U Unixu se koristi funkcija fork() za stvaranje novog procesa, a zatim exec() za zamjenu koda procesa. U Windowsima se koristi CreateProcess() za stvaranje novog procesa s definiranim parametrima.",
    "link": "https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 240,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Što je zamjena konteksta (context switch)?",
    "answer": "Zamjena konteksta je proces u kojem OS sprema stanje jednog procesa i učitava stanje drugog procesa iz PCB-a (Process Control Block), omogućujući multitasking.",
    "link": "https://www.geeksforgeeks.org/context-switching-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 241,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Koja su stanja procesa?",
    "answer": "Proces može biti u stanju: new, ready, running, waiting (blocked), terminated. Proces prelazi između ovih stanja ovisno o događajima u sustavu.",
    "link": "https://www.youtube.com/watch?v=jZ_6PXoaoxo"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 242,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Što se događa pri završetku procesa?",
    "answer": "Proces može završiti sam (pozivom exit()) ili biti prisilno završavan (npr. kill() pozivom). Završeni proces može postati \"zombie\" ako roditelj ne pokupi njegov status (kroz wait() ili signal handler).",
    "link": "https://www.geeksforgeeks.org/zombie-process-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 243,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Što je raspoređivanje procesa i koji su njegovi tipovi?",
    "answer": "Raspoređivanje procesa određuje koji će proces koristiti CPU. Postoje long-term, medium-term, short-term i I/O raspoređivači, koji zajedno upravljaju procesima u sustavu.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 244,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Koja je razlika između preemptivnog i ne-preemptivnog raspoređivanja?",
    "answer": "Preemptivno raspoređivanje omogućuje OS-u da prekine proces i preda CPU drugom procesu. Ne-preemptivno dopušta da proces koristi CPU dok ne završi ili se blokira.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 245,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Koje su popularne strategije raspoređivanja?",
    "answer": "FIFO (first in first out), Round Robin gdje svi procesi dobivaju isti vremenski kvantum, Priority Scheduling u kojem procesi s većim prioritetom imaju prednost, uz mogućnost \"aging\" da se izbjegne izgladnjivanje",
    "link": "https://www.studytonight.com/operating-system/cpu-scheduling"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 246,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Što su dretve i zašto ih koristimo?",
    "answer": "Dretva je lagana jedinica izvršavanja unutar procesa. Omogućuju paralelizam, dijeljenje resursa i bolju iskorištenost CPU-a jer se unutar istog procesa mogu paralelno izvršavati.",
    "link": "https://www.youtube.com/watch?v=hN2Yrf4tqTY"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 247,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Koje su prednosti dretvi nad procesima?",
    "answer": "Dretve su lakše i brže za kreiranje, brže mijenjaju kontekst, lakše dijele memoriju, omogućuju paralelno izvršavanje te bolje performanse u višedretvenim (multithreaded) i višejedrnim (multicore) sustavima.",
    "link": "https://www.youtube.com/watch?v=hwTYDQ0zZOw"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 248,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Što su POSIX dretve i kako se koriste?",
    "answer": "POSIX Threads (Pthreads) su standardno sučelje za rad s dretvama u C-u. Koriste se pomoću pthread_create, pthread_exit, pthread_join i drugih funkcija, uz uključivanje <pthread.h>.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 249,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Što znači usklađivanje poslovnih procesa?",
    "answer": "Usklađivanje poslovnih procesa označava proces prilagođavanja i optimizacije postojećih aktivnosti u skladu s poslovnim ciljevima i strategijama poduzeća. To uključuje standardizaciju, integraciju, kao i uvođenje promjena koje omogućuju efikasniji rad i bolju isporuku vrijednosti korisnicima.",
    "link": "https://www.procesnaanaliza.hr/uskladivanje-procesa/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 250,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koji su ciljevi usklađivanja procesa?",
    "answer": "Ciljevi usklađivanja procesa uključuju povećanje efikasnosti, smanjenje troškova, osiguranje kvalitete, poboljšanje korisničkog iskustva te usklađenost s regulatornim zahtjevima i strategijom poduzeća.",
    "link": "https://boc-group.com/blog/sto-je-uskladivanje-procesa-i-zasto-je-vazno/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 251,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koje su metode za usklađivanje poslovnih procesa?",
    "answer": "Postoje različite metode za usklađivanje poslovnih procesa, uključujući Business Process Reengineering (BPR), Lean, Six Sigma, TQM (Total Quality Management) i ISO standarde. Svaka metoda naglašava različite aspekte kao što su eliminacija gubitaka, kvaliteta, učinkovitost ili dokumentacija.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 252,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koji su izazovi kod usklađivanja procesa?",
    "answer": "Neki od glavnih izazova uključuju otpor zaposlenika prema promjenama, nedostatak jasne strategije, lošu komunikaciju, nedovoljno resursa te tehničke prepreke poput zastarjele IT infrastrukture.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 253,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Kako izgleda primjer usklađivanja procesa u organizaciji?",
    "answer": "Primjer može uključivati redizajn procesa zaprimanja narudžbi kako bi se smanjilo vrijeme obrade, uvođenje ERP sustava za bolju integraciju odjela te standardizaciju procedura kroz ISO norme kako bi se osigurala konzistentna kvaliteta.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 254,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koja je uloga IT-a u usklađivanju procesa?",
    "answer": "Informacijska tehnologija omogućuje digitalizaciju, automatizaciju i integraciju poslovnih procesa, čime se smanjuju greške, ubrzava obrada i poboljšava praćenje performansi. IT sustavi također omogućuju bolje donošenje odluka kroz dostupnost podataka u stvarnom vremenu.",
    "link": "https://www.cio.com/article/243716/role-of-it-in-business-process-management.html"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 255,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koji alati se koriste za modeliranje i analizu procesa?",
    "answer": "Najčešće korišteni alati uključuju BPMN (Business Process Model and Notation), ARIS, Bizagi, Lucidchart, Visio te razne ERP sustave poput SAP-a. Ovi alati omogućuju vizualizaciju, analizu i optimizaciju procesa.",
    "link": "https://kissflow.com/bpm/business-process-modeling-tools/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 256,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Što je procesna mapa (procesni dijagram)?",
    "answer": "Procesna mapa je grafički prikaz toka aktivnosti unutar procesa. Omogućuje bolji uvid u tijek rada, identifikaciju uskih grla i potencijalnih poboljšanja, te služi kao dokumentacija za standardizaciju procesa.",
    "link": "https://www.lucidchart.com/pages/process-map"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 257,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koji su problemi s semaforima?",
    "answer": "wait(S) i signal(S) mogu biti \"porazbacani\" na raznim mjestima u više procesa. Postaje jako teško pratiti njihovu funkciju i efekte koje imaju na izvršavanje, moraju se ispravno koristiti u svim procesima jer ako je jedan krivi proces možeuzrokovati probleme cijelom skupu procesa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 258,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što je Ljuska/Shell?",
    "answer": "program koji pruža CLI za interakciju s operacijskim sustavom. Bash je jedna od najčešće korištenih Unix/Linux ljuski.",
    "link": "https://www.youtube.com/watch?v=I4EWvMFj37g"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 259,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Kako se izrađuje i pokreće Bash skripta?",
    "answer": "Bash skripta je tekstualna datoteka koja sadrži niz naredbi za izvršavanje. Poželjno je da ima ekstenziju .sh, počinje s #!/bin/bash, a može se pokrenuti s : ./skripta.sh (ako je izvršna), bash skripta.sh ili . skripta.sh (sourcing)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 260,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Kako funkcioniraju dopuštenja (permissions) u Linuxu?",
    "answer": "Dopuštenja definiraju tko može čitati, pisati i izvršavati datoteke ili direktorije. Raspoređena su u tri seta: vlasnik, grupa, ostali. Prikazuju se pomoću ls -al, a podešavaju pomoću chmod.",
    "link": "https://www.tutorialspoint.com/unix/unix-file-permission.htm"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 261,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Kako se mijenjaju dopuštenja u Bashu?",
    "answer": "Dopuštenja se mjenjaju naredbom chmod i može poprimit 2 formata numerički (npr. Chmod 775 datoteka) ili simbolički (npr. Chmod u+x skripta.sh)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 262,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Što su wildcards?",
    "answer": "Wildcards su zamjenski znakovi koji omogućuju selekciju više datoteka kao npr \"*\" zamjenjuje bilo koji broj znakova, \"?\" Zamjenjuje jedan znak,  \" [ ABC ] \"  odabere niz znakova te \"[!ABC]\" sve osim tih znakova",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 263,
  "fields": {
    "lecture_id": 2,
    "subject": 3,
    "question": "Kako se koriste argumenti u Bash skriptama?",
    "answer": "Argumenti se pozivaju s $1, $2, ..., $@ (svi argumenti), $# (broj argumenata), a $0 daje ime skripte.",
    "link": "https://www.tutorialspoint.com/unix/unix-special-variables.htm"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 264,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Kako funkcionira grananje u Bashu?",
    "answer": "Bash koristi if, elif, else strukture. Uvjeti se mogu testirati sa [ ], [[ ]], (( )) ili pomoću naredbe test.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 265,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Zašto koristiti Bash skripte?",
    "answer": "Bash skripte služe za automatizaciju ponavljajućih zadataka, sistemsku administraciju, obradu datoteka, prilagodbu okruženja te integraciju sa softverskim alatima.",
    "link": "https://linuxhandbook.com/bash-script-reasons/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 266,
  "fields": {
    "lecture_id": 3,
    "subject": 3,
    "question": "Što radi naredba greb?",
    "answer": "grep je moćan alat za pretraživanje teksta unutar datoteka. Evo primjer primjene grab naredbe: grep \"traženi_tekst\" naziv_datoteke.txt",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 267,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Koji su sigurnosni rizici povezani s Bash skriptama?",
    "answer": "Bash skripte omogućuju automatizaciju zadataka i upravljanje sustavom, ali ako nisu pažljivo napisane, mogu omogućiti neovlašteni pristup, izvršavanje zlonamjernih naredbi i ugrožavanje integriteta sustava.",
    "link": "https://www.linuxjournal.com/content/securing-bash-scripts"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 268,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Zašto je hardcodanje lozinki u skriptama nesigurno?",
    "answer": "Uključivanje lozinki direktno u skriptu (hardcoded credentials) je nesigurno jer može dovesti do kompromitacije ako netko dobije pristup skripti. Lozinke trebaju biti pohranjene sigurno ili dohvaćene iz vanjskih izvora s pristupnim kontrolama.",
    "link": "https://cheatsheetseries.owasp.org/cheatsheets/Credential_Storage_Cheat_Sheet.html"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 269,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Kako neispravno korištenje navodnika može dovesti do grešaka u Bash skriptama?",
    "answer": "Ako se argumenti ne stavljaju u dvostruke navodnike, Bash može pogrešno protumačiti razmake, što može rezultirati neželjenim ponašanjem poput pogrešnog tumačenja imena datoteka ili izvršavanja dodatnih komandi.",
    "link": "https://mywiki.wooledge.org/Quotes"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 270,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Pitanje: Što je Bash command injection i kako ga izbjeći?",
    "answer": "Command injection omogućuje korisniku da ubaci i izvrši proizvoljne naredbe unutar skripte. To se može spriječiti pravilnim korištenjem navodnika i validacijom korisničkog unosa.",
    "link": "https://owasp.org/www-community/attacks/Command_Injection"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 271,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Koji je poznat primjer katastrofalne Bash skripte u praksi?",
    "answer": "Jedna verzija Steama za Linux imala je skriptu koja je mogla izbrisati cijeli korisnički direktorij (rm -rf \"$STEAMROOT/\"*) zbog pogrešno postavljene varijable STEAMROOT, što je dovelo do gubitka svih korisničkih podataka.",
    "link": "https://www.youtube.com/watch?v=qzZLvw2AdvM"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 272,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Kako pravilno postaviti putanju do direktorija skripte?",
    "answer": "Za određivanje direktorija gdje se nalazi skripta sigurno je koristiti readlink ili dirname \"$0\" umjesto samo ${0%/*}, što može uzrokovati greške ako se skripta pokreće iz različitih okruženja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 273,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Što je eskalacija privilegija?",
    "answer": "Eskalacija privilegija je iskorištavanje propusta u sustavu kako bi se dobio viši pristup, poput administratorskih ovlasti. To uključuje loše konfigurirane dozvole, stare softverske greške i slabosti u lozinkama.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 274,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Koja je razlika između stvarnog i efektivnog UID-a?",
    "answer": "Stvarni UID (rUID) označava stvarnog korisnika koji je pokrenuo proces, dok efektivni UID (eUID) određuje koje privilegije proces koristi tijekom izvršavanja, posebno važno za SUID datoteke.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 275,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Što su SUID datoteke i zašto su rizične?",
    "answer": "SUID (Set User ID) omogućuje izvršavanje datoteke s privilegijama njenog vlasnika, često root-a. Ako takva datoteka sadrži ranjivost, napadač može preuzeti administratorske ovlasti.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 276,
  "fields": {
    "lecture_id": 4,
    "subject": 3,
    "question": "Kako provjeriti je li lozinka kompromitirana?",
    "answer": "Možeš koristiti javne baze kompromitiranih lozinki, kao što je [SecLists], za usporedbu ili pogledati edukativne materijale o stvaranju jakih lozinki",
    "link": "https://www.youtube.com/watch?v=yzGzB-yYKcc"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 277,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koja je razlika između jezgrenog načina rada i korisničkog načina rada?",
    "answer": "Kod koji se izvršavau jezgrenom načinu rada može pristupiti bilo kojoj memorijskoj adresi i hardverskom resursu.  Također imaju visoka je razina privilegije, neograničen je pristup sklopovlju, potpuni pristup memoriji sustava te se konkretno odnosi na sam operacijski sustav.  Korisnički način rada imaju aplikacije na korisničkoj razini i imaju niske razine privilegija, ograničen pristup skopovlju, ograničen pristup memoriji sustava i izolirani su im problemi s aplikacijom.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 278,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koje operacije uključuju sistemske pozive?",
    "answer": "Upravljanje procesima, upravljanje datotekama, upravljanje uređajima, održavanje i infomacije, komunikacija, sigurnost",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 279,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Koje operacije ne uključuju sistemske pozive?",
    "answer": "Aritmetičke i logičke operacije, pristup i manipuliranje varijablama, pozivanje funkcija unutar istog programa ili biblioteke.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 280,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Što je proces? ",
    "answer": "Instanca računalnog programa u izvođenju. Procesi su međusobno nezavisni, čak i ako izvode isti program koriste zasebne resurse.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 281,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Za što je OS odgovoran ako govorimo o procesima?",
    "answer": "Os je odgovoran za kreiranje i brisanje korisničkih i sistemskih procesa, raspoređivanje procesa, osiguravanje mehanizma za usklađivanje, komunikaciju i upravljanje zastojima, …",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 282,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Objasni hijerarhiju procesa",
    "answer": "Linux je više-procesni OS, ali direktno poziva samo init proces s PID=1 koji je stalno u stanju izvršavanja (running). Ostali procesi se mogu smatrati djecom (children) tog procesa.  Svaki proces ima roditelja (parent). Proces može imati puno braće i sestara (siblings). Siblings procesi su stvoreni od istog roditelja. Djeca mogu stvarati djecu. ",
    "link": "https://www.youtube.com/watch?v=pSW9d3Oaie8"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 283,
  "fields": {
    "lecture_id": 5,
    "subject": 3,
    "question": "Što je signal?",
    "answer": "Signal je oblik komunikacije. Što to znači? Proces prima objaijesti o događajima koji utječu na njega. Te objavjesti su signali koje može biti poslan od strane jezgre ili nekog drugog procesa. Prede nirani skup signala, svaki ima identi kacijski broj i simbolično ime. Kada proces primi signal, on može ga ignorirat, izvršiti zadanuu radnji ili izvršiti prilagođenu radnju",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 284,
  "fields": {
    "lecture_id": 7,
    "subject": 1,
    "question": "Što je objekt i te koji su mu sastavni elementi?",
    "answer": "Objekt je skup svojstava (atributa) i metoda koja možemo objediniti u logičku cjelinu, a koristimo ih za apstrakciju svijeta oko nas. Atributi su opći podaci unutar objekta koji sadrže opise i stanja nekog objekta te služe za razlikovanje objekata. Metode definiraju ponašanje objekta kojima se opisuje što objekt može činiti, a može se koristiti i opis ponašanja koji je definiran objektom iz neke druge klase.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 285,
  "fields": {
    "lecture_id": 7,
    "subject": 1,
    "question": "Što je klasa te koja je veza objekta i klase?",
    "answer": "Klasa opisuje skup pravila koja propisuju od čega je objekt sagrađen, njegova svojstva i ponašanja. Svi objekti neke klase trebaju odgovarati opisu te klase. Na osnovu definicije klase mogu se izgraditi i održavati objekti, pri čemu vrijedi da je objekt konkretna realizacija klase.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 286,
  "fields": {
    "lecture_id": 7,
    "subject": 1,
    "question": "Što prikazuje dijagram klasa (eng. class diagram) te koje karakteristike opisuje?",
    "answer": "Dijagramom klas prikazuju se klase, od čega se sastoje i način na koji su klase objekta međusobno povezane koristeći se pritom: \\n-Atributima – varijablama primitivnog tipa ili objektima složenijih klasa koji definiraju izgled i znanja klase objekta\\n-Operacijama – metodama koje definiraju interno ponašanje unutar objekta i eksterno ponašanje kojim se ostvaruje međudjelovanje s drugim objektima\\n-Stereotipovima – zajedničkim karakteristikama grupi objekata zbog kojeg ih odlučimo objediniti u apstraktnu kategoriju, odnosno klasu\\n-Svojstvima – kojom definiramo svrhu i status objekta u modelu\\n-Asocijacijom – interakcije među klasama određenog tipa kojom definiramo smjer, višestrukost, ulogu, ograničenja, klasu i refleksivnost veze koje objekt podržava\\n-Generalizacijom – objedinjavanje više klasa sukladno zajedničkim svojstvima, odnosno razlučivanje klasa sukladno njihovoj specijalizaciji čime se pojednostavljuje i olakšava implementaciju.",
    "link": "https://www.lucidchart.com/pages/uml-class-diagram"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 287,
  "fields": {
    "lecture_id": 7,
    "subject": 1,
    "question": "Kako definiramo veze (eng. associations) između objekata u dijagramu klasa?",
    "answer": "Vezama se definira međudjelovanje između objekata različitih klasa, označavaju se linijama između klasa, a svakoj se pridodijeli: Ime (eng. association name) koje opisuje način međudjelovanja, Smjer strelicom u smjeru čitanja, Višestrukost (eng. association multiplicity) koja definira broj objekata koji mogu učestvovati u vezi, Uloge veza (eng. association roles) koje se koriste kada je teško definirati ulogu samo pomoću njezina imena, Ograničenja koja se definiraju unutar vitičastih zagrada, Klasa veze (eng. association class) koja definira podatke koji se prenose tom vezom. Jačina veze može biti određene kao asocijacija (slaba veza među klasama), agregacija (kada su objekti međusobno zavisni u međudjelovanju, odnosno kada se povezuju u kompleksniju cjelinu) ili kompozicija (koja podrazumijeva agregaciju i uvodi pravilo da svaki dio može biti član skupine samo dok ta skupina postoji jer samostalan nema smisla)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 288,
  "fields": {
    "lecture_id": 7,
    "subject": 1,
    "question": "Za što se koristi te koji su osnovni elementi dijagrama sekvenci (eng. sequence diagram)?",
    "answer": "Dijagram sekvenci se koristi za modeliranje dinamičke perspektive problema, odnosno o ponašanje objekata pri izvođenju operacija. Sastavni elementi su mu: životna linija objekta (eng. obeject lifeline) označena vertikalnom linijom koja predstavlja postojanje nekog objekta u određenom vremenu, poruka (eng. message) označena strelicom koja predstavlja komunikaciju između objekata i prenosi informaciju koja akcija slijedi te izvršenje slučaja (eng. activation box) označen visokim, tankim pravokutnikom koji prikazuje period vremena tokom kojeg objekt izvršava radnju. Same poruke pri tome mogu biti stimulativne, povratne, iterativne, a sadržavati broj sekvence, uvjete i komentare.",
    "link": "https://www.geeksforgeeks.org/unified-modeling-language-uml-sequence-diagrams/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 289,
  "fields": {
    "lecture_id": 7,
    "subject": 1,
    "question": "Razlike u rezultatima benchmarkinga prema vrsti zadatka",
    "answer": "Performanse jezika ovise o zadatku. Algoritamski zahtjevni zadaci bolje prolaze u jezicima poput C/C++ i Rusta zbog blizine hardveru. IO zadaci ovise o knjižnicama i asinkronom izvođenju, pa prednjače Go, Java i JavaScript. Kod konkurentnosti se ističu Go i Rust. Zaključno, nijedan jezik nije najbolji za sve – svaki ima specifične prednosti.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 290,
  "fields": {
    "lecture_id": 7,
    "subject": 1,
    "question": "Utjecaj tipa jezika, memorije i optimizacija na performanse",
    "answer": "Kompajlirani jezici (npr. C) su brži jer se prevode u strojni kod, dok su interpretirani (npr. Python) sporiji. JIT (npr. Java) kombinira oba pristupa. Upravljanje memorijom utječe na performanse – garbage collector može usporiti, dok ručno upravljanje nudi veću kontrolu. Optimizacije kompajlera dodatno poboljšavaju brzinu.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 291,
  "fields": {
    "lecture_id": 7,
    "subject": 1,
    "question": "Uloga benchmarkinga i važni faktori za relevantnost",
    "answer": "Benchmarking uspoređuje jezike mjerenjem brzine, memorije i CPU-a u različitim zadacima. Da bi bio relevantan, testovi moraju biti standardizirani, ponovljivi, uzimati u obzir hardver, optimizacije, knjižnice i runtime okruženja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 292,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Što je to enkapsulacija?",
    "answer": "Enkapsulacija ili učahurivanje je jedan od temeljnih koncepata objektno orijentirane paradigme programiranja, a služi prikrivanju podataka s ciljem njihove zaštite i pojednostavljenja korištenja programiranih funkcionalnosti. Korisnici nekog objekta ne moraju znati sadržaj, tj. program unutar klase, već dobivaju usluge te klase preko definiranih sučelja, odnosno javnih metoda, a direktne izmjene vrijednosti između objekata se izbjegavaju. Implementacija klasa se skriva od korisnika pomoću pristupnih razina private i protected, a pristup odabranim skrivenim podacima omogućen je preko članskih metoda definiranih na public pristupnoj razini (get i set metode)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 293,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Koja je osnovna razlika između proceduralno orijentiranog programiranja i objektno orijentiranog programiranja?",
    "answer": "Proceduralno orijentirani program izveden je kao skup funkcija, zbog čega je algoritamski pristup dominantan, a njegovo izvršavanje ostvaruje se funkcijom main iz koje se pozivaju sve ostale na izvršavanje. S druge strane, u objektno orijentiranim programskim jezicima, program se sastoji od skupa klasa iz kojih se instanciraju objekti prilikom izvođenja programa. Objekti se sastoje od podataka koji čine njegovo stanje i metoda kojima se ostvaruje njegovo djelovanje, a izvođenjem programa ostvaruje se komunikacija među objekatima",
    "link": "https://www.geeksforgeeks.org/difference-between-oop-and-pop/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 294,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Nabroji i objasni osnovne principe objektno orijentiranog programiranja.",
    "answer": "Apstrakcija – program je skup objekta koji se instanciraju iz klasa. Kod pisan u objektno orijentiranom programskom jeziku sastoji se od jedne ili više klasa. Enkapsulacija – Upotrebom odgovarajućih modifikatora pristupa, objekti ne moraju znati detalje implementacije jedni o drugima, već samo funkcionalnosti koje oni pružaju. Nasljeđivanje – Povećava ponovnu iskoristivost koda tako da postojeći superklase kod naslijedimo u podklasi, po potrebi preradimo, dodatno specijaliziramo te prilagodimo novoj primjeni. Polimorfizam – u objektno orijentiranom programiranju je omogućeno da referiranjem na objekte iz superklase omogućeno pozivati metode i iz podklasa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 295,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Kakva je to slojevita arhitektura programskog proizvoda. Navedi osnovne karakteristike, prednosti i nedostatke",
    "answer": "Slojevita arhitektura (eng. layered architecture) programskog proizvoda je organizacija sustava u kojoj se srodne funkcionalnosti grupiraju po slojevima. Svaki sloj daje usluge sloju iznad svojeg i traži usluge od sloja niže, a najniži sloj sadrži jezgrene / osnovne funkcionalnosti. Primjenjuje se kod sustava kod kojeg se očekuje nadogradnja funkcionalnosti na postojeće stanje, distribuiranog razvoja i strogih sigurnosnih zahtjeva na više razina. Prednosti slojevite arhitekture su omogućena zamjena sloja uz korištenje standardnih sučelja te redundantnost za svaki sloj.\\n Nedostaci slojevite arhitekture su vezani uz problem: \\n(1) razlaganja sustava na slojeve\\n (2) zahtjeva da svaki sloj može komunicirati samo s određenim slojevima\\n (3) performansi zbog povećane komunikacije uzrokovane ograničenom komunikacijom.",
    "link": "https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 296,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Kakva je to arhitektura repozitorija podataka. Navedi osnovne karakteristike, prednosti i nedostatke.",
    "answer": "Kod arhitekture repozitorija podataka (eng. data repository architecture) upravljanje svim podacima u sustavu je unutar centralnog repozitorija koji je dostupan svim komponentama sustava. Na taj način komponente sustava nemaju direktnu vezu već isključivo preko podataka pohranjenih u repozitoriju. Primjena takve arhitekture je kod većine sustava koji koriste velike količine podataka koju se trebaju pohraniti na neko vrijeme. Prednosti arhitekture repozitorija podataka su: nezavisnost komponenata koje ne moraju znati za postojanje ostalih komponenti u sustavu te konzistentno upravljanje podatcima. Nedostaci arhitekture repozitorija podataka su što jedna pogreška ima utjecaj na cijeli sustav, a komunikacija koja se odvija preko repozitorija je neučinkovita.",
    "link": "https://www.geeksforgeeks.org/repository-design-pattern/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 297,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Što je uparenost (eng. coupling)? Navedi barem jednu karakteristiku kvalitete na koju utječe uparenost te obrazloži odgovor.",
    "answer": "Uparenost (eng.coupling) je mjera međusobne povezanosti modula. Visoka razina uparenosti predstavlja veliku zavisnost između modula, što znači da promjene u jednom uzrokuju promjene u drugom modulu. Takvo stanje nije poželjno jer negativno utječe na jednostavnost održavanja budući da je komponente manje zavisnosti jednostavnije mijenjati, a samim time i održavati. Drugim riječima, poželjno je imati slabu uparenost između modula (loose coupling).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 298,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Što je to kohezija (eng. cohesion)? Kakva uparenost i kohezija čine dobar dizajn programskog proizvoda? Obrazloži odgovor.",
    "answer": "Kohezija (eng. cohesion) je mjera kojom se definira koliko su dijelovi komponenata povezani (npr. programi su kohezivni ako su sve naredbe povezane sa svakim izlazom, a klase su kohezivne ako su svi atributi korišteni od strane svih metoda), a poželjno je imati čim veću koheziju. Dobar dizajn okarakteriziran je niskom uparenošću i visokom kohezijom. Uparenost opisuje odnos između dvije komponente sustava, kada promjene u jednoj komponenti uzrokuju promjene u drugoj. Poželjno je stoga imati čim manju uparenost da bi komponente bile čim nezavisnije. Kohezija opisuje povezanost podataka i izlaza programa, odnosno atributa i metoda. Visoka kohezija nam govori da je klasa fokusirana na izvršavanje funkcionalnosti kojoj je namijenjena, a ne da izvršava „svašta pomalo“, a takve klase lakše je održavati",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 299,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Nabroji i obrazloži osnovne koncepte koji se koriste za ugradnju kvalitete u programski proizvod",
    "answer": "Apstrakcija – omogućava usredotočivanje na nužne detalje i skrivanje nevažnih, čime se uvelike pojednostavljuje analiza složenih problema. \\nPrikrivanje podataka (eng. data hiding) – omogućava da su podaci jednog modula nevidljivi drugim modulima sustava kako se ne bi mogli mijenjati i time uzrokovati pogrešku. Tako smanjujemo uparenost modula s njihovom okolinom i olakšavamo njegovo održavanje. \\nSloženost – treba biti što manja kako ne bi uzrokovala probleme otežanog razumijevanja, čitljivosti održavanja, ponovne primjene te pouzdanosti. Mjera složenosti su razne, a mogu biti izražene vremenom rješavanja problema ili razvoja modula, brojem linija koda (LOC), kombinacijom internih atributa programa (duljina, broj LOC, broj if naredbi i sl.), brojem slijednih instrukcija i dr. \\nStruktura sustava – pomoću usmjerenog grafa prikazuje se hijerarhija zavisnosti (eng. dependencies) između modula koje mogu biti: modul A sadrži / slijedi / isporučuje podatke / koristi modul B.\\n Modularnost (eng. modularity) – omogućava podjelu programa na nezavisne module koji imaju dobro definirane veze.\\nOsnovne karakteristike usporedbe dizajna jesu: \\nKohezija (eng. cohesion) – mjera kojom se definira koliko su dijelovi komponenti povezani\\nUparenost (eng.coupling) – mjera međusobne povezanosti modula.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 300,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Opiši princip objektno orijentiranog dizajna u strategiji izgradnje programskih sustava",
    "answer": "Objektno orijentirani dizajn (eng. Object oriented – OO design) koristi dijagrame za opis statičke (class i object) i dinamičke (state, sequence, colaboration) slike sustava. Tehnika dizajna svodi se u tri koraka: identifikacija objekata, identifikacija atributa i metoda svakog objekta, identifikacija veza i odnosa između objekata. Nedostatci su: metode pretpostavljaju stabilne ulazne zahtjeve, nisu pogodne za definiranje zahtjeva, smjernice za identifikaciju objekata i atributa nisu egzaktne, nema definiranog načina odabira najboljeg modela, teško se identificiraju implicitni objekti sustava. Prednosti su: model opisa sustava je prirodniji i razumljiviji, veza problema koji se modelira i modela je očita, dizajn se fokusira na strukturiranje problema a ne solucije problema, sustavi izgrađeni na osnovu oo dizajna su fleksibilniji na promjene, ponovno korištenje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 301,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Kako indeksirani tipovi u Wasm-prechecku poboljšavaju sigurnost i performanse WebAssembly programa?",
    "answer": "Indeksirani tipovi omogućuju statičku provjeru uvjeta poput provjere granica memorije i kompatibilnosti funkcijskih potpisa prije izvođenja, čime uklanjaju potrebu za skupim dinamičkim provjerama u runtime-u. Time se smanjuje broj sigurnosnih provjera i postiže značajno ubrzanje izvršavanja koda.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 302,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Koji je doprinos tehnike \"lifted interpretation\" u procesu sinteze programa s lokalnim varijablama?",
    "answer": "Lifted interpretation omogućuje simultano razmatranje svih mogućih konteksta lokalno vezanih varijabli tijekom sinteze, što drastično smanjuje prostor pretrage bez potrebe za ručnom enumeracijom svih kombinacija vezivanja. Time se ubrzava sinteza i omogućuje rad s kompleksnijim programskim strukturama, poput lambda izraza.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 303,
  "fields": {
    "lecture_id": 8,
    "subject": 1,
    "question": "Zašto je kontrolno-tokovna linearnost (C-linearity) važna za sigurno upravljanje resursima u programima s efektima?",
    "answer": "Kontrolno-tokovna linearnost osigurava da se linearni resursi (npr. file-deskriptori) koriste točno jednom čak i u prisutnosti effect-handlera koji omogućuju višestruke pozive ili odbacivanje nastavaka (continuations). Time se sprječava curenje resursa ili njihovo neželjeno dupliciranje, što je ključno za sigurnost i stabilnost programa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 304,
  "fields": {
    "lecture_id": 9,
    "subject": 1,
    "question": "U kontekstu pogrešaka i neispravnosti programskog proizvoda, kakva može biti njihova veza te što se traži testiranjem?",
    "answer": "Pogreška je unesena ljudskom nepažnjom u program i odnosi se na krivo napisanu naredbu dok je neispravnost manifestacija pogreške pri izvođenju programa. Jedna pogreška, uzrokovana ljudskom nepažnjom, može se manifestirati u više različitih neispravnost prilikom izvođenja programa. Također, više pogrešaka se može manifestirati kao jedna neispravnost.\\nTestiranje je proces izvođenja programa ili komponenti programa pod određenim, unaprijed planiranim uvjetima u kojem se promatraju rezultati izvođenja programa i uspoređuje sa zahtijevanim uvjetima. U kontekstu pogrešaka i neispravnosti, testiranjem se pronalaze neispravnosti, a cilj je otkriti i ispraviti pogreške u kodu, koja je izazvana ljudskom nepažnjom.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 305,
  "fields": {
    "lecture_id": 9,
    "subject": 1,
    "question": "Koja je razlika između verifikacije i validacije, koje aktivnosti uključuju te koji su im ciljevi?",
    "answer": "Proces verifikacije podrazumijeva procjenu programskog proizvoda i pripadajuće dokumentacije u ispunjenju zadanih zahtjeva i/ili uvjeta. Verifikacijom odgovaramo na pitanje „gradimo li proizvod na ispravan način?“ (npr. je li programski kod sintaktički ili logički ispravan?).\\nProcesom validacije provjerava se u kojoj mjeri programski proizvod i pripadajuća dokumentacija ispunjavaju korisnikove specificirane zahtjeve. Validacijom odgovarmo na pitanje „gradimo li pravi proizvod?“ (npr. radi li programski kod ono što korisnik od njega očekuje?).\\nVerifikacijske aktivnosti uključuju inspekcije - statičku verifikaciju programskog proizvoda povezanu s procjenom postojanja pogrešaka u statičkoj slici programskog proizvoda te testiranje - dinamičku verifikaciju programskog proizvoda povezanu s promatranjem ponašanja programskog proizvoda za vrijeme izvođenja programa. Cilj verifikacije i validacije su pronalazak pogrešaka, povećanje pouzdanosti, minimizacija rizika (pomoć u donošenju odluke o puštanju u rad ili prodaju, minimizirati troškove tehničke podrške, procijeniti sukladnost s specifikacijom, normama i sl.) te procjena kvalitete",
    "link": "https://www.geeksforgeeks.org/differences-between-verification-and-validation/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 306,
  "fields": {
    "lecture_id": 9,
    "subject": 1,
    "question": "Kako klasificiramo tehnike testiranja?",
    "answer": "Tehnike testa se mogu klasificirati s obzirom na kriterij odabira testnih slučajeva: \\n-Testiranje zasnovano na pokrivenosti testom (engl. Coverage-based testing) kod kojeg su zahtjevi testiranja specificirani obzirom na pokrivenost testiranog programa\\n-Testiranje zasnovano na neispravnostima (engl. Fault-based testing) kod kojeg se testni slučajevi fokusiraju na otkrivanje neispravnosti u radu sustava\\n- Testiranje zasnovano na pogreškama (engl. Error-based testing) kod kojeg su testni slučajevi zasnovani na poznavanju tipičnih mjesta u programskom kodu koji su podložni pogreškama (posebice u krivoj uporabi)\\nTakođer, mogu se klasificirati prema izvoru informacije za provođenje testnih slučajeva na:\\n-Funkcionalno testiranje ili testiranje principom crne kutije (eng. black box testing) kod kojeg su testni slučajevi izvedeni iz specifikacije zahtjeva, a implementacijski detalji su nevažni\\n-Strukturno testiranje ili testiranje principom bijele kutije (eng. white / glass box testing) kod kojeg se analizira interna logika i struktura",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 307,
  "fields": {
    "lecture_id": 9,
    "subject": 1,
    "question": "Koje aktivnosti obavljamo testiranjem u pojedinim fazama životnog ciklusa programskog proizvoda?",
    "answer": "U inženjerstvu zahtjeva se određuje testna strategija, specifikacija testnih zahtjeva te generiranje funkcionalnih testnih podataka. U fazi dizajna se vrši provjera usklađenost dizajna i specifikacije zahtjeva, procjena arhitekture, testiranje dizajna, te generiranje funkcionalnih i strukturalnih testnih podataka. U fazi implementacije se vrši provjera usklađenosti dizajna i implementacije, testiranje implementacija, generiranje funkcionalnih i strukturalnih testnih podataka te se izvode testovi. U fazi održavanja se ponavlja prethodna testiranja u skladu sa stupnjem razvoja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 308,
  "fields": {
    "lecture_id": 9,
    "subject": 1,
    "question": "Koje razine testiranja razlikujemo u životnom ciklusu programskog proizvoda?",
    "answer": "Testiranje se obično provodi prateći strukturu sustava. Razine testiranja u životnom ciklusu su:\\n-Testiranje programske jedinice (eng. unit test) u kojem se testiraju najmanje jedinice u sustavu\\n-Test integracije (funkcijsko testiranje) u kojem se testiraju integracije programskih jedinica u sustav, pri čemu je integracija sustava inkrementalni proces, a razlikujemo testiranje odozdo prema gore, odozgo prema dolje i funkcijsku integraciju\\n-Testiranje sustava koje se vrši prema korisničkoj dokumentaciji i specifikaciji zahtjeva\\n-Testiranje prihvatljivosti (eng. acceptance testing) koje je slično kao testiranje sustava samo što se test provodi pod nadzorom korisničke organizacije (naglasak na mogućnosti korištenja sustava), te se koristi kriterij za prihvat sustava zadan od strane korisnika\\n-Instalacijski test (eng. instalation testing) koji se vrši kada je sustav prihvaćen, a potrebno ga je testirati u okolini kojoj je namijenjen raditi",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 309,
  "fields": {
    "lecture_id": 10,
    "subject": 1,
    "question": "Koje karakteristike programskog proizvoda ulaze u definiciju modela kvalitete prema ISO 9126 standardu?",
    "answer": "Standard ISO 9126 definira model kvalitete kao niz karakteristika koje programski proizvod promatraju iz različitih perspektiva korisnika, ali i osoba uključenih u njegov razvoj:\\nFunkcionalnost – postojanje skupa funkcija koje su zadane ili podrazumijevane -> Koliko je proizvod pogodan za obavljanje tražene funkcije, koliko točno ispunjava zadane zahtjeve, koliko je interoperabilan, siguran u radu i sl.\\n-Pouzdanost – sposobnost ostvarenja zadane razine performansi kroz zadano vrijeme -> Koliko je proizvod zreo, otporan na neispravnosti, koliko se brzo može oporaviti od kvarova i sl.\\n-Uporabljivost – procjena individualnog truda potrebnog za uporabu -> Koliko je proizvod razumljiv korisniku, intuitivan za korištenje, operabilan, atraktivan i sl.\\n-Efikasnost – odnos razine performansi i količine utrošenih resursa -> Koliko proizvod troši i koliko zahtijeva računske moći te je li dovoljno optimiziran\\n-Lakoća održavanja - procjena truda potrebnog za promjenu funkcionalnosti i održavanje -> Koliko je proizvod jednostavno analizirati, prilagođavati i testirati te koliko je pri takvim izmjenama stabilan\\n-Prenosivost – sposobnost prenošenja iz jednog okruženja u drugo -> Koliko je proizvod adaptabilan i zamjenjiv, pokazuje li pri tome znakove nestabilnosti te koliko dobro djeluje uz druge proizvode u okruženju",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 310,
  "fields": {
    "lecture_id": 10,
    "subject": 1,
    "question": "Koja je svrha i koji su osnovni ciljevi osiguranja kvalitete programskog proizvoda?",
    "answer": "Osnovna svrha osiguravanja kvalitete programskog proizvoda (eng. Software quality assurance, SQA) je osigurati da se posao izgradnje obavi na ispravan način sa što manje grešaka, prekoračenja rokova i neispunjenih zahtjeva. Ciljevi SQA su sljedeći:\\n-Unaprijediti kvalitetu programskog proizvoda kroz sustavan nadzor programskog proizvoda u razvoju i nadzor samog tijeka procesa razvoja.\\n-Osigurati potpunu primjenu standardiziranih procesa razvoja i procedura.\\n-Osigurati da se za sve neusklađenosti produkta, procesa ili standarda privuče pozornost menadžmenta kako bi se neusklađenosti ispravile na vrijeme.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 311,
  "fields": {
    "lecture_id": 10,
    "subject": 1,
    "question": "Koja je razlika između pogreške (eng. error) i neispravnosti (eng. fault) u odnosu na definiciju s predavanja?",
    "answer": "Pogreška je unesena ljudskom nepažnjom u program i odnosi se na krivo napisanu naredbu dok je neispravnost manifestacija pogreške pri izvođenju programa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 312,
  "fields": {
    "lecture_id": 10,
    "subject": 1,
    "question": "Kako dijelimo tehnike osiguravanja kvalitete. Opiši formalnu inspekciju i kako ju primjenjujemo?",
    "answer": "Tehnike osiguranja kvalitete dijelimo na:\\nFormalni pristup - inspekcije (inspections)\\nNeformalni pristup - pregledi (review ili walkthrough). \\nPokazalo se da su formalni pristupi bolji od neformalnih. Formalna inspekcija je planirana formalna aktivnost gdje dizajner predstavlja dokument koji se pregledava i odabrana grupa inspektora procjenjuje tehničke aspekte dizajna. Načini izvedbe inspekcije mogu se razlikovati s time da su osnovne značajke formalnih inspekcija sljedeće: inspekciju provode barem 3 osobe – stručnjaka za odabrano područje, od kojih jedan je autor, inspekcija se vrši rutinski u razvoju, prema definiranim ulogama (moderator, voditelj, zapisničar, autor) i procesu (priprema, inspekcija, unos ispravaka i follow up) koristeći strukturirani model (kontrolna lista) kojim se pregledava potpun dokument s ciljem otkrivanja pogrešaka i nedostataka.\\nMetrika koja se koristi obično je Broj pogrešaka / KLOC ili Broj pogrešaka / uloženi broj sati.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 313,
  "fields": {
    "lecture_id": 10,
    "subject": 1,
    "question": "Koji su osnovni podaci koje bi trebao sadržavati dokument osiguravanja kvalitete programskog proizvoda?",
    "answer": "Osnovnih podaci o osiguranje kvalitete trebali bi pojasniti PLAN provedbe aktivnosti verifikacije i validacije te pri tome odgovoriti na pitanja poput:\\n1. Tko, kada i koliko često provodi aktivnosti? Važno je znati koje osobe i u kojem trenutku unutar faza razvoja projekta trebaju vršiti izvjesne inspekcije ili preglede.\\n2. Što i kako se pregledava? Potrebno je navesti koje sve isporuke (eng. deliverables) ili procese njihova stvaranja treba kontrolirati te na koji način – kojom tehnikom i alatom, kakvim predefiniranim formularima, u skladu s kojim standardom i sl.\\n3. Kako se vrše mjerenja? Potrebno je definirati kojim metrikama će se provjeriti odvijaju li se stvari prema planu, kako ih izračunati, s kojim referentnim vrijednostima ih usporediti i sl. 4.\\nKako se izvještavaju problemi i koje korektivne aktivnosti su na raspolaganju? Ukoliko se aktivnostima verifikacije i validacije (naročito programskog koda) ustanove neispravnosti, važno je znati kome i kako ih treba prijaviti te što možemo ili moramo učiniti kako bi ih uklonili ili njihov utjecaj ublažili.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 314,
  "fields": {
    "lecture_id": 10,
    "subject": 1,
    "question": "Po čemu se PRODEC metoda razlikuje od klasičnih metoda za analize zadataka u dizajnu sustava?",
    "answer": "Za razliku od klasičnih metoda koje polaze od unaprijed definiranih procedura o pretpostavki o ponašanju korisnika. PRODEC se temelji na stvarnih iskustvima i simulacijama s uključenim korisnicima. Kroz te simulacije, sustav se iterativno prilagođava",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 315,
  "fields": {
    "lecture_id": 10,
    "subject": 1,
    "question": "Kako RISE varira s obzirom na vodopadni/kaskadni model razvoja i mijenja li ga u potpunosti?",
    "answer": "RISE model nije direktna RISE model nije direktna zamjena za vodopadni model razvoja, koristi se u specifičnim scenarijima gdje se treba prilagoditi novim režimima sustava koji su karakterizirani",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 316,
  "fields": {
    "lecture_id": 10,
    "subject": 1,
    "question": "Zašto su simulacije sintetičkih putanja korisne za procjenu sigurnosti?",
    "answer": "Simulacije sintetičkih putanja korisne su jer omogućuju testiranje različitih scenarija i procjenu sigurnosnih prijetnji u situacijama koje se rijetko javljaju u stvarnim podacima, poput ekstremnih vremenskih uvjeta, manjih odstupanja ili ljudskih grešaka.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 317,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je zastoj?",
    "answer": "Procesi međusobno čekaju resurse koje drže drugi procesi, stvarajući kružno čekanje bez izlaza.",
    "link": "https://www.geeksforgeeks.org/introduction-of-deadlock-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 318,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koji su primjeri iz stvarnog svijeta za zastoj?",
    "answer": "Uski tunel: dva automobila koja dolaze s različitih strana ne mogu proći istovremeno.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 319,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koja su četiri nužna uvjeta za nastanak zastoja?",
    "answer": "Međusobno isključivanje, zadrži i čekaj, nema iznuđivanja, kružno čekanje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 320,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Je li dovoljno da 4 glavna uvijeta zadovoljena da se zastoj dogodi?",
    "answer": "procesi međusobno čekaju resurse koje drže drugi procesi, stvarajući kružno čekanje bez izlaza.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 321,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako nastaje zastoj kod semafora?",
    "answer": " Kada procesi koriste semafore u različitom redoslijedu: P1- wait(S); wait(Q) i P2- wait(Q); wait(S);",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 322,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako dolazi do zastoja kod memorije?",
    "answer": "Kad procesi traže više memorije u fazama koje se međusobno blokiraju.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 323,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako komunikacija može uzrokovati zastoj?",
    "answer": "Ako proces A čeka poruku od procesa B, a B čeka poruku od A.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 324,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je dijagram dodjeljivanja resursa?",
    "answer": "Graf s čvorovima za procese i resurse, gdje strelice označavaju zahtjeve i dodjele.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 325,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako prepoznati zastoj u grafu?",
    "answer": "Ako postoji kružni put, postoji potencijalni zastoj.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 326,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako se može spriječiti zastoj?",
    "answer": "Onemogućavanjem barem jednog od uvjeta: 1. Zabraniti „zadrži i čekaj“, 2. Dozvoliti iznuđivanje, 3. Izbjegavati kružno čekanje poretkom resursa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 327,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Zašto je sprječavanje zastoja nepraktično?",
    "answer": "Često je neefikasno i može dovesti do lošeg iskorištavanja resursa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 328,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je Bankarov algoritam?",
    "answer": "Algoritam koji simulira dodjelu resursa i provjerava da li sustav ostaje u sigurnom stanju.",
    "link": "https://www.geeksforgeeks.org/bankers-algorithm-in-operating-system-2/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 329,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kada se zahtjev za resursom odbija prema Bankarovu algoritmu?",
    "answer": "Ako proces traži više od prijavljenog maksimuma ili ako sustav ulazi u nesigurno stanje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 330,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako operacijski sustav otkriva zastoj?",
    "answer": "Periodičkom provjerom grafa dodjele resursa pomoću algoritma za otkrivanje zastoja.",
    "link": "https://www.geeksforgeeks.org/deadlock-detection-algorithm-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 331,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako znati koji su procesi u zastoju?",
    "answer": "Procesi koji na kraju algoritma ostanu neoznačeni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 332,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako se može riješiti zastoj?",
    "answer": "Zastoj se može riješiti: prekidom procesa, rollbackom procesa ili iznuđivanjem resursa",
    "link": "https://www.geeksforgeeks.org/deadlock-handling-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 333,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koji je kriterij za odabir procesa za prekid?",
    "answer": "Prioritet, vrsta procesa, količina resursa koje koristi i broj prethodnih rollbackova",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 334,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je kombinirani pristup upravljanju zastojima?",
    "answer": "Kombinacija prevencije, izbjegavanja i otkrivanja, ovisno o vrsti resursa i efikasnosti.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 335,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je uloga upravljanja memorijom u operacijskom sustavu?",
    "answer": "Upravljanje memorijom omogućuje učitavanje više procesa u memoriju, njihovu zaštitu, dijeljenje memorije i učinkovito korištenje resursa. Također omogućuje logičku i fizičku separaciju memorijskih adresa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 336,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koje su glavne faze povezivanja adresa u memoriji?",
    "answer": "Povezivanje adresa može se vršiti: 1. Tijekom prevođenja(compile time), 2.prilikom učitavanja(load time), 3. za vrijeme izvršavanja(execution time), gdje je potrebna hardverska podrška (base i limit registri)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 337,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je dinamičko punjenje?",
    "answer": "Potprogrami i funkcije se učitavaju u memoriju samo kad se pozovu, čime se smanjuje iskorištenost memorije jer se učitavaju samo stvarno korištene funkcije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 338,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja je razlika između statičkog i dinamičkog povezivanja?",
    "answer": "Statičko povezivanje uključuje sistemske knjižnice pri kompilaciji, dok se dinamičko povezivanje obavlja tijekom izvođenja i omogućuje dijeljenje koda među procesima.",
    "link": "https://www.geeksforgeeks.org/static-and-dynamic-linking-in-operating-systems/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 339,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koji su osnovni zahtjevi upravljanja memorijom?",
    "answer": "Premještanje (relocation), zaštita (protection), dijeljenje (sharing), logička i fizička organizacija memorije",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 340,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je Memory Management Unit?",
    "answer": "MMU je sklop koji pretvara logičke (virtualne) adrese u fizičke, često pomoću base i limit registara. Time se omogućuje izolacija između procesa i fleksibilnije upravljanje memorijom.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 341,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je prebacivanje u kontekstu memorije?",
    "answer": "Proces se može privremeno ukloniti iz glavne memorije i smjestiti u sekundarnu memoriju da bi se oslobodilo mjesto za druge procese. Kasnije se može vratiti za nastavak izvršavanja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 342,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koji su problemi fiksnog particioniranja memorije?",
    "answer": "Glavni problem je unutarnja fragmentacija, jer svaki proces zauzima cijelu particiju, bez obzira na stvarnu veličinu.",
    "link": "https://www.geeksforgeeks.org/difference-between-internal-and-external-fragmentation/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 343,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je vanjska fragmentacija i kako se rješava?",
    "answer": "Vanjska fragmentacija nastaje kad postoji dovoljno ukupne slobodne memorije, ali ne u jednom komadu. Rješava se zbijanjem memorije (compaction).",
    "link": "https://www.geeksforgeeks.org/difference-between-internal-and-external-fragmentation/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 344,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je buddy system?",
    "answer": "To je sustav za dinamičku dodjelu memorije u blokovima veličine 2^k. Kad se memorija oslobodi, blokovi se mogu spajati ako su „parovi” (buddies).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 345,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako funkcionira straničenje?",
    "answer": "Straničenje dijeli memoriju na jednake blokove (stranice i okvire - frames). Proces koristi tablicu stranica za preslikavanje virtualnih adresa u fizičke.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 346,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Čemu služi Translation Lookaside Buffer?",
    "answer": "TLB je cache koji pohranjuje nedavno korištene preslikavanja stranica, čime ubrzava pristup memoriji izbjegavajući stalne pristupe glavnoj memoriji.",
    "link": "https://www.geeksforgeeks.org/translation-lookaside-buffer-tlb-in-paging/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 347,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je segmentacija u upravljanju memorijom?",
    "answer": "Segmentacija omogućuje logičku podjelu programa na segmente (npr. kod, podaci), različitih veličina, s posebnim pravima pristupa i vidljivim programeru.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 348,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja je razlika između straničenja i segmentacije?",
    "answer": "Straničenje koristi fiksne veličine stranica i nevidljivo je programeru. Segmentacija koristi varijabilne veličine segmenata i vidljiva je programeru. Obje se mogu kombinirati.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 349,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je virtualna memorija i kako funkcionira?",
    "answer": "Virtualna memorija omogućuje da proces koristi više memorije nego što fizički postoji, učitavanjem samo potrebnih dijelova u glavnu memoriju prema potrebi.",
    "link": "https://www.geeksforgeeks.org/virtual-memory-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 350,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je računalna sigurnost i zašto je važna?",
    "answer": "Računalna sigurnost odnosi se na zaštitu računalnih sustava i podataka od neovlaštenog pristupa, oštećenja ili krađe. U informatičkom dobu, gdje su informacije temelj modernog načina života, sigurnost je ključna za očuvanje povjerljivosti, integriteta i dostupnosti podataka.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 351,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koji su osnovni sigurnosni zahtjevi računalnih sustava?",
    "answer": "Osnovni sigurnosni zahtjevi uključuju: Povjerljivost: samo autorizirani korisnici imaju pristup informacijama, Integritet: samo auzorizirani korisnici mogu mijenjati informacije, Dostupnost: informacije moraju biti dostupne autoriziranim korisnicima, Autentičnost: sustav provjerava valjanost indentiteta subjeka",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 352,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je Denial of Service napad?",
    "answer": "DoS napad je pokušaj onemogućavanja pristupa servisu ili sustavu zakonitim korisnicima, često preopterećenjem resursa. Distribuirani DoS (DDoS) napadi koriste više kompromitiranih uređaja za izvođenje napada.",
    "link": "https://stytch.com/blog/10-common-cyber-attacks"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 353,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koji su najčešći oblici zlonamjernog softvera?",
    "answer": "Najčešći oblici uključuju: Spyware: Prikuplja informacije bez znanja korisnika, Keylogger: Bilježi pritiske tipki kako bi ukrao lozinke i druge osjetljive podatke, Dialer: Automatski bira brojeve, često skupe, bez znanja korisnika, Rootkit: Omogućuje neautorizirani pristup sustavu skrivajući se od detekcije",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 354,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Kako se možemo obraniti od sigurnosnih prijetnji?",
    "answer": "Edukacija korisnika, redovite sigurnosne kopije(backup), implementacija sigurnosnih politika, korištenje jakih lozinki i njihovo redovito mijenjanje, ažuriranje sustava i softvera, korištenje kriptografije, primjena vatrozida (firewall) i VPN-a, korištenje antivirusnih programa i sustava za otkrivanje upada (IDS)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 355,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je kriptografija i koje su osnovne metode šifriranja?",
    "answer": "Kriptografija je znanost o zaštiti informacija pretvaranjem čitljivih podataka u neprepoznatljiv oblik. Simetično šifriranje: isti ključ se koristi za šifriranje i dešifriranje podataka, Asimetrično šifriranje: koriste se dva različita ključa - javni za šifriranje i privatni za dešifriranje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 356,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Zašto su lozinke važan aspekt sigurnosti i kako ih pravilno koristiti?",
    "answer": " Lozinke su prva linija obrane u zaštiti računalnih sustava. Dobra lozinka treba biti kompleksna, jedinstvena i redovito mijenjana. Također, važno je ne dijeliti lozinke i koristiti upravitelje lozinki za njihovo sigurno pohranjivanje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 357,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je dvofaktorska autentifikacija i kako poboljšava sigurnost?",
    "answer": "2FA dodaje dodatni sloj sigurnosti zahtijevajući dva oblika identifikacije prije pristupa sustavu: Nnešto što korisnik zna npr. lozinka ili PIN ili nešto što korisnik ima kao npr. mobilni uređaj, token ili biometrijski podatak",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 358,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Kako socijalni inženjering predstavlja prijetnju sigurnosti?",
    "answer": "Socijalni inženjering manipulira ljudima kako bi otkrili povjerljive informacije. Primjeri uključuju phishing napade, lažne pozive ili poruke koje se predstavljaju kao legitimne kako bi prevarili korisnike.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 359,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koje su preporuke za zaštitu od phishing napada?",
    "answer": "Preporuke su: pažljivo provjeravanje e-mail adresa i linkova, ne otvaranje sumnjivih privitaka, korištenje sigurnosnih alata koji detektiraju phising pokušaje, edukacija korisnika o prepoznavanju lažnih poruka",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 360,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je sigurnosna politika i zašto je važna?",
    "answer": "Sigurnosna politika je skup pravila i procedura koje organizacija uspostavlja kako bi zaštitila svoje informacijske resurse. Ona definira odgovornosti, dopuštenja i postupke u slučaju sigurnosnih incidenata.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 361,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što su sistemski pozivi?",
    "answer": "Sistemski pozivi su sučelje (API) između korisničkih programa i jezgre operacijskog sustava. Omogućuju korisničkim programima da traže usluge od jezgre, poput čitanja datoteka, upravljanja memorijom i procesa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 362,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koja je razlika između jezgrenog i korisničkog načina rada?",
    "answer": "Korisnički način rada (privilegijska razina 3) ograničava pristup hardveru i resursima sustava, dok jezgreni način rada (privilegijska razina 0) ima puni pristup sustavu. Sistemski pozivi omogućuju sigurnu komunikaciju između ta dva načina.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 363,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako funkcionira izvršavanje sistemskog poziva?",
    "answer": "Izvršava se ASM instrukcija syscall, koja prebacuje program iz korisničkog u jezgreni način rada. Identifikacijski broj željenog sistemskog poziva postavlja se u eax registar, a zatim se koristi tablica sistemskih poziva kako bi se pronašao odgovarajući handler na fiksnoj adresi.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 364,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je system call handler?",
    "answer": "To je dio jezgre operacijskog sustava koji prima i obrađuje sistemski poziv kada dođe iz korisničkog načina rada.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 365,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako su sistemski pozivi implementirani u Linuxu?",
    "answer": "Linux koristi syscall instrukciju za pozivanje funkcija iz jezgre. Svakom pozivu dodijeljen je jedinstveni broj koji se koristi za pronalaženje funkcije u tablici sistemskih poziva.",
    "link": "https://filippo.io/linux-syscall-table/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 366,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Zašto je pristup sistemskim pozivima drugačiji na Windowsima?",
    "answer": "Kod Windowsa izvorni kod jezgre nije javno dostupan pa se sistemski pozivi ne mogu direktno inspektirati. Umjesto toga, dostupna je dokumentacija za Win32 API koji omogućuje razvoj softvera za Windows bez direktnog uvida u sistemske pozive.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 367,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je proces?",
    "answer": "Proces je instanca računalnog programa u izvođenju. Svaki proces koristi vlastite resurse poput CPU-a, memorije, datoteka i I/O uređaja. Čak i ako dva procesa izvršavaju isti program, oni su međusobno nezavisni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 368,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koje su osnovne odgovornosti operacijskog sustava vezane uz procese?",
    "answer": "Operacijski sustav je odgovoran za kreiranje i brisanje korisničkih i sistemskih procesa, za njihovo raspoređivanje odnosno scheduling, te za osiguravanje mehanizama kojima se upravlja međusobnom sinkronizacijom, komunikacijom među procesima i zastojima koji mogu nastati.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 369,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako izgleda struktura procesa u memoriji?",
    "answer": "Struktura procesa u memoriji podijeljena je u nekoliko dijelova. Stog se koristi za privremene podatke poput parametara funkcija, povratnih adresa i lokalnih varijabli. Hrpa je dio memorije koji se dinamički alocira tijekom izvršavanja procesa. Podatkovni dio sadrži globalne i statičke varijable, dok tekstualni dio sadrži izvršni kod programa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 370,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je Process Control Block?",
    "answer": "Process Control Block, skraćeno PCB, je podatkovna struktura koja čuva sve važne informacije o procesu. Te informacije uključuju jedinstveni identifikacijski broj procesa (Process ID), adresu sljedeće instrukcije koja će se izvršiti (Program Counter), informacije o korištenju ulazno-izlaznih uređaja, podatke za raspoređivanje procesa poput prioriteta i pokazivača na redove čekanja te statističke podatke o korištenju CPU-a i vremenskim ograničenjima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 371,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja su osnovna stanja procesa?",
    "answer": "Osnovna stanja procesa uključuju stanja u kojima se proces može nalaziti tijekom svog životnog ciklusa, a to su: novo (new), spremno (ready), u izvođenju (running), u čekanju (waiting) i završeno (terminated). Svaki proces prelazi iz jednog stanja u drugo ovisno o događajima tijekom svog izvođenja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 372,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što se događa kada proces primi signal?",
    "answer": "Kada proces primi signal, on može reagirati na nekoliko načina. Može ignorirati signal, iako neki signali ne mogu biti ignorirani. Također može izvršiti zadanu, unaprijed definiranu radnju, ili može izvršiti vlastitu, prilagođenu funkciju koja obrađuje taj signal. Ta se funkcija naziva signal handler. Jezgra tada obavlja zamjenu konteksta kako bi pozvala handler, a nakon njegovog izvršavanja, kontrola se vraća izvornom procesu.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 373,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako izgleda hijerarhija procesa u Linuxu?",
    "answer": "U Linux operacijskom sustavu, prvi proces koji se pokreće je proces pod nazivom init i ima identifikacijski broj PID=1. Taj proces je uvijek u stanju izvršavanja i svi ostali procesi se smatraju njegovom djecom ili potomcima. Svaki proces u sustavu ima svog roditelja, a može imati i više \"braće i sestara\", odnosno druge procese koje je stvorio isti roditeljski proces. Djeca također mogu stvarati vlastitu djecu, čime nastaje hijerarhijska struktura procesa. Uz init postoje i alternativni sustavi za pokretanje procesa, poput systemd-a, Upstarta, OpenRC-a, Epocha i Mudara.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 374,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Zašto se koristi višedretvenost?",
    "answer": "Višedretvenost se koristi kako bi se omogućilo izvođenje više neovisnih tokova instrukcija istovremeno, pri čemu te dretve dijele zajednički adresni prostor. Time se postiže paralelizam dijeljenjem jednog procesa na više dretvi, što povećava učinkovitost i iskorištenost procesora.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 375,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koja je razlika između procesa i dretvi?",
    "answer": "Procesi su izolirani jedni od drugih i koriste zaseban memorijski prostor, dok dretve dijele zajednički memorijski prostor i ovise jedna o drugoj. Stvaranje i komunikacija među procesima imaju veći vremenski trošak (overhead), dok su dretve lakše (lightweight) i brže u komunikaciji. Također, pogreške u jednom procesu ne utječu na druge procese, dok greška u jednoj dretvi može utjecati na sve ostale dretve unutar istog procesa. Kod dretvi je zbog dijeljenja resursa potrebna sinkronizacija, dok kod procesa to često nije slučaj.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 376,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koja je razlika između programa s jednom dretvom i programa s više dretvi?",
    "answer": "Program s jednom dretvom izvršava sve zadatke sekvencijalno, što može uzrokovati blokiranje cijelog programa ako dođe do zahtjevne operacije. S druge strane, program s više dretvi omogućava da se pojedini dijelovi aplikacije izvode paralelno, čime se poboljšava responzivnost i ukupna učinkovitost.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 377,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koje su prednosti korištenja dretvi?",
    "answer": "Korištenje dretvi omogućava bolju responzivnost programa jer se kompleksni zahtjevi mogu izvršavati bez blokiranja drugih dijelova aplikacije. Također se smanjuje vrijeme potrebno za prebacivanje konteksta, jer je manji overhead nego kod procesa. Komunikacija između dretvi je jednostavnija i učinkovitija jer dijele memorijski prostor. Osim toga, dretve poboljšavaju skalabilnost jer omogućuju iskorištavanje paralelizma u višeprocesorskim sustavima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 378,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koje vrste dretvi postoje?",
    "answer": "Postoje dvije glavne vrste dretvi: korisničke (user threads) i jezgrene (kernel threads). Korisničke dretve implementirane su u korisničkom prostoru bez izravne podrške jezgre i obično su jednostavne za implementaciju. Jezgrene dretve podržava sama jezgra operacijskog sustava i omogućuju izvođenje više zadataka paralelno na razini jezgre, ali njihova implementacija je složenija.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 379,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Kako se korisničke dretve mapiraju na jezgrene dretve?",
    "answer": "Korisničke dretve mogu se mapirati na jezgrene dretve koristeći jednu od tri strategije: „many to one“, gdje više korisničkih dretvi koristi jednu jezgrenu dretvu; „one to one“, gdje svaka korisnička dretva ima svoju jezgrenu dretvu; te „many to many“, gdje više korisničkih dretvi može koristiti više jezgrenih dretvi, ali ne nužno u omjeru jedan na jedan.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 380,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Što je utrkivanje  i kada nastaje?",
    "answer": "Utrkivanje nastaje kada više dretvi istovremeno pokušava pristupiti i mijenjati zajedničke resurse, a redoslijed izvršavanja tih operacija nije definiran. To dovodi do neočekivanih ponašanja programa ili pogrešnih rezultata. Utrkivanje se obično događa u kritičnim sekcijama koda gdje se provode operacije tipa \"read-modify-write\" ili \"check-then-act\".",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 381,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Što je sinkronizacija i kako pomaže kod upravljanja dretvama?",
    "answer": "Sinkronizacija je mehanizam koji rješava probleme poput utrkivanja među dretvama. Uključuje korištenje atomskih operacija, semafora i međusobnog isključivanja (mutex). ",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 382,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Kako radi mutex?",
    "answer": "Mutex radi slično binarnom semaforu, ali se temelji na zaključavanju resursa kako bi se osiguralo da samo jedna dretva u određenom trenutku ima pristup kritičnoj sekciji.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 383,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što je međuprocesna komunikacija?",
    "answer": "Međuprocesna komunikacija (IPC) je mehanizam koji operacijski sustav pruža kako bi procesi mogli međusobno komunicirati i upravljati dijeljenim resursima. Omogućuje sinkronizaciju i razmjenu podataka među procesima koji se izvršavaju istovremeno.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 384,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira komunikacija putem dijeljene memorije?",
    "answer": "Komunikacija putem dijeljene memorije podrazumijeva pisanje i čitanje podataka u zajednički memorijski prostor. Procesi koji koriste dijeljenu memoriju odmah vide promjene, što čini ovu metodu najbržom. Međutim, zahtijeva pažljivo upravljanje pristupom pomoću semafora kako bi se izbjegli problemi istovremenog pristupa, slično kao u višedretvenim programima.",
    "link": "https://www.geeksforgeeks.org/inter-process-communication-ipc-shared-memory/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 385,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što je memorijsko mapiranje i kako se koristi u IPC-u?",
    "answer": "Memorijsko mapiranje omogućuje procesima da komuniciraju putem datoteka koje su mapirane u njihovu memoriju. Operacijski sustav upravlja pristupom datotekama, a procesi tretiraju mapirani dio kao da je dio njihove glavne memorije. Promjene u memoriji automatski se prenose u povezane datoteke.",
    "link": "https://learn.microsoft.com/en-us/windows/win32/memory/creating-a-file-mapping-object"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 386,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira cjevovod u međuprocesnoj komunikaciji?",
    "answer": "Cjevovod je jednosmjeran kanal između dva procesa. Jedan proces upisuje podatke, dok drugi čita. Najčešće se koristi između povezanih procesa, poput roditeljskog i podprocesa. Cjevovod postoji samo dok su povezani procesi aktivni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 387,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Po čemu se imenovani cjevovod razlikuje od običnog cjevovoda?",
    "answer": "Imenovani cjevovod (FIFO) ima ime u datotečnom sustavu, što omogućuje komunikaciju i između nepovezanih procesa. Procesi mogu neovisno otvarati, zatvarati, čitati i pisati u FIFO.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 388,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira komunikacija porukama?",
    "answer": "Komunikacija porukama omogućuje slanje i primanje poruka putem redova poruka. Poruke se obično obrađuju redoslijedom dolaska, ali postoji mogućnost da se pojedine poruke ciljano povuku prije nego dođu na red, što pruža veću fleksibilnost od FIFO.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 389,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što su signali i kako se koriste u IPC-u?",
    "answer": "Signali su oblik softverskih prekida koje procesi koriste za obavještavanje drugih procesa o određenim događajima. Signale može slati drugi proces ili jezgra sustava. Kad proces primi signal, može izvršiti određenu funkciju poznatu kao signalni rukovatelj (handler).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 390,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Koji oblik međuprocesne komunikacije će biti obrađen sljedeći tjedan?",
    "answer": "Sljedeći tjedan planira se obrada IPC-a putem utičnica (sockets), koje omogućuju komunikaciju između procesa na različitim računalima putem mreže.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 391,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Što su utičnice u kontekstu međuprocesne komunikacije?",
    "answer": "Utičnice su mehanizam koji omogućuje međuprocesnu komunikaciju između više procesa na istom računalu ili između računala unutar iste mreže. Podaci se šalju u obliku paketa, a najčešće se koristi model poslužitelj-klijent. Utičnice omogućuju fleksibilan i standardiziran način komunikacije putem mreže.",
    "link": "https://en.wikipedia.org/wiki/Network_socket"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 392,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koje je tri stvari potrebno definirati prilikom stvaranja socket-a?",
    "answer": "Prilikom stvaranja socket-a potrebno je definirati stil komunikacije, namespace i protokol. Stil komunikacije određuje način na koji se podaci prenose, namespace određuje adresni prostor i način na koji se socket identificira, a protokol definira pravila prijenosa podataka između krajnjih točaka komunikacije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 393,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koje su osnovne razlike između stream i datagram utičnica?",
    "answer": "Stream utičnice predstavljaju oblik komunikacije koji je pouzdan i osigurava da svi paketi stignu na odredište redoslijedom kojim su poslani. Ako neki paket ne stigne, automatski se ponovno šalje, što omogućuje točnu i sigurnu isporuku podataka. Takav način rada nalikuje TCP protokolu. S druge strane, datagram utičnice ne garantiraju isporuku paketa niti njihov redoslijed, već se fokusiraju na brzinu prijenosa. U slučaju gubitka paketa, nema ponovnog slanja. Ovakav način rada podsjeća na UDP komunikaciju, gdje je brzina prioritet nad pouzdanošću.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 394,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Što predstavlja namespace kod socket-a?",
    "answer": "Namespace kod socket-a predstavlja način na koji se adresira jedna krajnja točka komunikacije. Ako se koristi lokalni namespace, adresa se odnosi na datoteku u datotečnom sustavu, čime se socket identificira pomoću imena datoteke. Ako se koristi mrežni namespace, adresa socket-a sastoji se od IP adrese hosta i broja porta, čime se omogućuje komunikacija između udaljenih računala preko mreže.",
    "link": "https://en.wikipedia.org/wiki/Unix_domain_socket"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 395,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koju ulogu ima protokol kod socket-a?",
    "answer": "Protokol kod socket-a određuje način na koji će se podaci prenositi između procesa. On definira pravila komunikacije i ponašanje tijekom razmjene informacija. Neki od najčešće korištenih protokola su TCP/IP, koji osigurava pouzdan prijenos podataka, i UDP, koji omogućuje brži ali manje pouzdan prijenos. Osim mrežnih protokola, za lokalnu komunikaciju koristi se i UNIX lokalni protokol, dok se u specifičnim okruženjima može naići na starije protokole poput AppleTalk-a.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 396,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koji su osnovni sistemski pozivi pri radu sa socket-ima?",
    "answer": "Pri radu sa socket-ima koristi se niz sistemskih poziva koji omogućuju stvaranje i upravljanje socket-ima. Proces započinje stvaranjem socket-a pomoću poziva socket, nakon čega se socket povezuje s adresom pomoću bind ako se radi o poslužitelju. Potom se socket stavlja u stanje slušanja s pozivom listen, a klijent koristi connect kako bi uspostavio vezu. Kada poslužitelj primi zahtjev, koristi accept za prihvaćanje veze. Za razmjenu podataka koriste se read i write, dok se na kraju veze socket zatvara pozivom close.",
    "link": "https://en.wikipedia.org/wiki/Berkeley_sockets"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 397,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je upravljanje memorijom?",
    "answer": "Upravljanje memorijom je funkcionalnost operacijskog sustava kojom se omogućuje učitavanje više procesa u radnu memoriju i raspoređivanje te memorije među njima. Operacijski sustav vodi računa o tome koji dijelovi memorije su zauzeti, koji su slobodni, i kako optimalno dodijeliti memorijske resurse svakom procesu tako da se postigne učinkovito korištenje memorije i izbjegnu konflikti među procesima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 398,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji su problemi povezani s fiksnim particioniranjem memorije?",
    "answer": "Kod fiksnog particioniranja memorije, ukupna memorija podijeljena je na unaprijed definirane blokove fiksne veličine. Glavni problem ovog pristupa je unutarnja fragmentacija, koja nastaje kada proces zauzme više memorije nego što mu je stvarno potrebno, ali se svejedno dodjeljuje cijeli blok. Zbog toga dolazi do neučinkovitog korištenja memorije, a dodatni problem je i ograničen broj procesa koji mogu istovremeno biti aktivni, jer broj particija definira maksimalan broj procesa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 399,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji je glavni problem dinamičkog particioniranja memorije?",
    "answer": "Glavni problem kod dinamičkog particioniranja memorije je vanjska fragmentacija. To se događa kada tijekom vremena u memoriji nastanu brojni mali, nepovezani slobodni prostori koji zajedno možda čine dovoljno memorije za novi proces, ali zbog njihove razdvojenosti operacijski sustav ne može alocirati memoriju u jednom komadu. Zbog toga može doći do situacije u kojoj se novi proces ne može učitati, iako ukupno ima dovoljno slobodne memorije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 400,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je zbijanje memorije i kada se koristi?",
    "answer": "Zbijanje memorije je postupak kojim operacijski sustav premješta podatke u memoriji s ciljem uklanjanja vanjske fragmentacije. Premještanjem aktivnih procesa u jedan dio memorije, oslobađa se kontinuirani blok memorije koji se može dodijeliti novim procesima. Ova operacija povećava učinkovitost korištenja memorije, ali također predstavlja dodatni trošak za sustav jer zahtijeva vrijeme i resurse za pomicanje podataka.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 401,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji algoritmi se koriste za dodjelu slobodnih memorijskih blokova?",
    "answer": "Postoji nekoliko algoritama koji se koriste za odabir slobodnih blokova memorije kada novi proces zatraži prostor. Prvi algoritam, First-fit, traži prvi dovoljno veliki blok i odmah ga dodjeljuje. Next-fit je sličan, ali nastavlja pretraživanje od mjesta gdje je prethodna alokacija završila. Best-fit traži najmanji blok koji je dovoljno velik za proces, kako bi se ostavilo što manje neiskorištenog prostora. Suprotno tome, Worst-fit odabire najveći dostupni blok, s namjerom da podijeljeni ostatak nakon alokacije bude dovoljno velik za buduće zahtjeve. Svaki od ovih algoritama ima svoje prednosti i nedostatke u pogledu brzine i količine fragmentacije koju uzrokuje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 402,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je buddy system i kako funkcionira?",
    "answer": "„Buddy system“ je metoda upravljanja memorijom koja predstavlja kompromis između fiksnog i dinamičkog particioniranja. U ovom sustavu, memorija se dijeli na blokove veličine koji su potencije broja dva, a kada je potrebno, veći blokovi se dijele na manje. Ako su dva susjedna bloka slobodna i imaju istu veličinu, oni se mogu ponovno spojiti u veći blok. Ovaj sustav omogućuje fleksibilnu i učinkovitu dodjelu memorije uz smanjenu fragmentaciju i brže pronalaženje slobodnog prostora.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 403,
  "fields": {
    "lecture_id": 13,
    "subject": 3,
    "question": "Koji su osnovni sigurnosni zahtjevi i sigurnosne prijetnje u informacijskim sustavima?",
    "answer": "Sigurnosni zahtjevi informacijskih sustava temelje se na četiri ključna principa: povjerljivosti, integritetu, dostupnosti i autentičnosti. Povjerljivost podrazumijeva da su podaci dostupni samo ovlaštenim osobama, a ne smiju ih presresti treće strane, što se naziva presretanjem. Integritet znači da podaci ostaju neizmijenjeni osim ako ih ne izmijeni netko s odgovarajućim ovlastima, a svako neautorizirano mijenjanje predstavlja sigurnosnu prijetnju poznatu kao modifikacija. Dostupnost osigurava da sustav i njegovi resursi budu dostupni korisnicima kad god su im potrebni, dok je prekid rada ili pristupa sustavu prijetnja koja ugrožava dostupnost. Autentičnost se odnosi na vjerodostojnost komunikacije ili identiteta korisnika, a sigurnosna prijetnja koja ugrožava autentičnost naziva se fabrikacija, jer uključuje lažno predstavljanje ili izmišljanje podataka.",
    "link": "https://ocw.mit.edu/courses/6-858-computer-systems-security-fall-2014/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 404,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je zastoj?",
    "answer": "Procesi međusobno čekaju resurse koje drže drugi procesi, stvarajući kružno čekanje bez izlaza.",
    "link": "https://www.geeksforgeeks.org/introduction-of-deadlock-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 405,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koji su primjeri iz stvarnog svijeta za zastoj?",
    "answer": "Uski tunel: dva automobila koja dolaze s različitih strana ne mogu proći istovremeno.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 406,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koja su četiri nužna uvjeta za nastanak zastoja?",
    "answer": "Međusobno isključivanje, zadrži i čekaj, nema iznuđivanja, kružno čekanje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 407,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Je li dovoljno da 4 glavna uvijeta zadovoljena da se zastoj dogodi?",
    "answer": "procesi međusobno čekaju resurse koje drže drugi procesi, stvarajući kružno čekanje bez izlaza.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 408,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako nastaje zastoj kod semafora?",
    "answer": " Kada procesi koriste semafore u različitom redoslijedu: P1- wait(S); wait(Q) i P2- wait(Q); wait(S);",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 409,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako dolazi do zastoja kod memorije?",
    "answer": "Kad procesi traže više memorije u fazama koje se međusobno blokiraju.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 410,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako komunikacija može uzrokovati zastoj?",
    "answer": "Ako proces A čeka poruku od procesa B, a B čeka poruku od A.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 411,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je dijagram dodjeljivanja resursa?",
    "answer": "Graf s čvorovima za procese i resurse, gdje strelice označavaju zahtjeve i dodjele.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 412,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako prepoznati zastoj u grafu?",
    "answer": "Ako postoji kružni put, postoji potencijalni zastoj.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 413,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako se može spriječiti zastoj?",
    "answer": "Onemogućavanjem barem jednog od uvjeta: 1. Zabraniti „zadrži i čekaj“, 2. Dozvoliti iznuđivanje, 3. Izbjegavati kružno čekanje poretkom resursa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 414,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Zašto je sprječavanje zastoja nepraktično?",
    "answer": "Često je neefikasno i može dovesti do lošeg iskorištavanja resursa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 415,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je Bankarov algoritam?",
    "answer": "Algoritam koji simulira dodjelu resursa i provjerava da li sustav ostaje u sigurnom stanju.",
    "link": "https://www.geeksforgeeks.org/bankers-algorithm-in-operating-system-2/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 416,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kada se zahtjev za resursom odbija prema Bankarovu algoritmu?",
    "answer": "Ako proces traži više od prijavljenog maksimuma ili ako sustav ulazi u nesigurno stanje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 417,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako operacijski sustav otkriva zastoj?",
    "answer": "Periodičkom provjerom grafa dodjele resursa pomoću algoritma za otkrivanje zastoja.",
    "link": "https://www.geeksforgeeks.org/deadlock-detection-algorithm-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 418,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako znati koji su procesi u zastoju?",
    "answer": "Procesi koji na kraju algoritma ostanu neoznačeni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 419,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako se može riješiti zastoj?",
    "answer": "Zastoj se može riješiti: prekidom procesa, rollbackom procesa ili iznuđivanjem resursa",
    "link": "https://www.geeksforgeeks.org/deadlock-handling-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 420,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koji je kriterij za odabir procesa za prekid?",
    "answer": "Prioritet, vrsta procesa, količina resursa koje koristi i broj prethodnih rollbackova",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 421,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je kombinirani pristup upravljanju zastojima?",
    "answer": "Kombinacija prevencije, izbjegavanja i otkrivanja, ovisno o vrsti resursa i efikasnosti.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 422,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je uloga upravljanja memorijom u operacijskom sustavu?",
    "answer": "Upravljanje memorijom omogućuje učitavanje više procesa u memoriju, njihovu zaštitu, dijeljenje memorije i učinkovito korištenje resursa. Također omogućuje logičku i fizičku separaciju memorijskih adresa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 423,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koje su glavne faze povezivanja adresa u memoriji?",
    "answer": "Povezivanje adresa može se vršiti: 1. Tijekom prevođenja(compile time), 2.prilikom učitavanja(load time), 3. za vrijeme izvršavanja(execution time), gdje je potrebna hardverska podrška (base i limit registri)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 424,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je dinamičko punjenje?",
    "answer": "Potprogrami i funkcije se učitavaju u memoriju samo kad se pozovu, čime se smanjuje iskorištenost memorije jer se učitavaju samo stvarno korištene funkcije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 425,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja je razlika između statičkog i dinamičkog povezivanja?",
    "answer": "Statičko povezivanje uključuje sistemske knjižnice pri kompilaciji, dok se dinamičko povezivanje obavlja tijekom izvođenja i omogućuje dijeljenje koda među procesima.",
    "link": "https://www.geeksforgeeks.org/static-and-dynamic-linking-in-operating-systems/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 426,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koji su osnovni zahtjevi upravljanja memorijom?",
    "answer": "Premještanje (relocation), zaštita (protection), dijeljenje (sharing), logička i fizička organizacija memorije",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 427,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je Memory Management Unit?",
    "answer": "MMU je sklop koji pretvara logičke (virtualne) adrese u fizičke, često pomoću base i limit registara. Time se omogućuje izolacija između procesa i fleksibilnije upravljanje memorijom.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 428,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je prebacivanje u kontekstu memorije?",
    "answer": "Proces se može privremeno ukloniti iz glavne memorije i smjestiti u sekundarnu memoriju da bi se oslobodilo mjesto za druge procese. Kasnije se može vratiti za nastavak izvršavanja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 429,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koji su problemi fiksnog particioniranja memorije?",
    "answer": "Glavni problem je unutarnja fragmentacija, jer svaki proces zauzima cijelu particiju, bez obzira na stvarnu veličinu.",
    "link": "https://www.geeksforgeeks.org/difference-between-internal-and-external-fragmentation/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 430,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je vanjska fragmentacija i kako se rješava?",
    "answer": "Vanjska fragmentacija nastaje kad postoji dovoljno ukupne slobodne memorije, ali ne u jednom komadu. Rješava se zbijanjem memorije (compaction).",
    "link": "https://www.geeksforgeeks.org/difference-between-internal-and-external-fragmentation/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 431,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je buddy system?",
    "answer": "To je sustav za dinamičku dodjelu memorije u blokovima veličine 2^k. Kad se memorija oslobodi, blokovi se mogu spajati ako su „parovi” (buddies).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 432,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako funkcionira straničenje?",
    "answer": "Straničenje dijeli memoriju na jednake blokove (stranice i okvire - frames). Proces koristi tablicu stranica za preslikavanje virtualnih adresa u fizičke.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 433,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Čemu služi Translation Lookaside Buffer?",
    "answer": "TLB je cache koji pohranjuje nedavno korištene preslikavanja stranica, čime ubrzava pristup memoriji izbjegavajući stalne pristupe glavnoj memoriji.",
    "link": "https://www.geeksforgeeks.org/translation-lookaside-buffer-tlb-in-paging/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 434,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je segmentacija u upravljanju memorijom?",
    "answer": "Segmentacija omogućuje logičku podjelu programa na segmente (npr. kod, podaci), različitih veličina, s posebnim pravima pristupa i vidljivim programeru.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 435,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja je razlika između straničenja i segmentacije?",
    "answer": "Straničenje koristi fiksne veličine stranica i nevidljivo je programeru. Segmentacija koristi varijabilne veličine segmenata i vidljiva je programeru. Obje se mogu kombinirati.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 436,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je virtualna memorija i kako funkcionira?",
    "answer": "Virtualna memorija omogućuje da proces koristi više memorije nego što fizički postoji, učitavanjem samo potrebnih dijelova u glavnu memoriju prema potrebi.",
    "link": "https://www.geeksforgeeks.org/virtual-memory-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 437,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je računalna sigurnost i zašto je važna?",
    "answer": "Računalna sigurnost odnosi se na zaštitu računalnih sustava i podataka od neovlaštenog pristupa, oštećenja ili krađe. U informatičkom dobu, gdje su informacije temelj modernog načina života, sigurnost je ključna za očuvanje povjerljivosti, integriteta i dostupnosti podataka.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 438,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koji su osnovni sigurnosni zahtjevi računalnih sustava?",
    "answer": "Osnovni sigurnosni zahtjevi uključuju: Povjerljivost: samo autorizirani korisnici imaju pristup informacijama, Integritet: samo auzorizirani korisnici mogu mijenjati informacije, Dostupnost: informacije moraju biti dostupne autoriziranim korisnicima, Autentičnost: sustav provjerava valjanost indentiteta subjeka",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 439,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je Denial of Service napad?",
    "answer": "DoS napad je pokušaj onemogućavanja pristupa servisu ili sustavu zakonitim korisnicima, često preopterećenjem resursa. Distribuirani DoS (DDoS) napadi koriste više kompromitiranih uređaja za izvođenje napada.",
    "link": "https://stytch.com/blog/10-common-cyber-attacks"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 440,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koji su najčešći oblici zlonamjernog softvera?",
    "answer": "Najčešći oblici uključuju: Spyware: Prikuplja informacije bez znanja korisnika, Keylogger: Bilježi pritiske tipki kako bi ukrao lozinke i druge osjetljive podatke, Dialer: Automatski bira brojeve, često skupe, bez znanja korisnika, Rootkit: Omogućuje neautorizirani pristup sustavu skrivajući se od detekcije",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 441,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Kako se možemo obraniti od sigurnosnih prijetnji?",
    "answer": "Edukacija korisnika, redovite sigurnosne kopije(backup), implementacija sigurnosnih politika, korištenje jakih lozinki i njihovo redovito mijenjanje, ažuriranje sustava i softvera, korištenje kriptografije, primjena vatrozida (firewall) i VPN-a, korištenje antivirusnih programa i sustava za otkrivanje upada (IDS)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 442,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je kriptografija i koje su osnovne metode šifriranja?",
    "answer": "Kriptografija je znanost o zaštiti informacija pretvaranjem čitljivih podataka u neprepoznatljiv oblik. Simetično šifriranje: isti ključ se koristi za šifriranje i dešifriranje podataka, Asimetrično šifriranje: koriste se dva različita ključa - javni za šifriranje i privatni za dešifriranje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 443,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Zašto su lozinke važan aspekt sigurnosti i kako ih pravilno koristiti?",
    "answer": " Lozinke su prva linija obrane u zaštiti računalnih sustava. Dobra lozinka treba biti kompleksna, jedinstvena i redovito mijenjana. Također, važno je ne dijeliti lozinke i koristiti upravitelje lozinki za njihovo sigurno pohranjivanje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 444,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je dvofaktorska autentifikacija i kako poboljšava sigurnost?",
    "answer": "2FA dodaje dodatni sloj sigurnosti zahtijevajući dva oblika identifikacije prije pristupa sustavu: Nnešto što korisnik zna npr. lozinka ili PIN ili nešto što korisnik ima kao npr. mobilni uređaj, token ili biometrijski podatak",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 445,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Kako socijalni inženjering predstavlja prijetnju sigurnosti?",
    "answer": "Socijalni inženjering manipulira ljudima kako bi otkrili povjerljive informacije. Primjeri uključuju phishing napade, lažne pozive ili poruke koje se predstavljaju kao legitimne kako bi prevarili korisnike.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 446,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koje su preporuke za zaštitu od phishing napada?",
    "answer": "Preporuke su: pažljivo provjeravanje e-mail adresa i linkova, ne otvaranje sumnjivih privitaka, korištenje sigurnosnih alata koji detektiraju phising pokušaje, edukacija korisnika o prepoznavanju lažnih poruka",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 447,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je sigurnosna politika i zašto je važna?",
    "answer": "Sigurnosna politika je skup pravila i procedura koje organizacija uspostavlja kako bi zaštitila svoje informacijske resurse. Ona definira odgovornosti, dopuštenja i postupke u slučaju sigurnosnih incidenata.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 448,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što su sistemski pozivi?",
    "answer": "Sistemski pozivi su sučelje (API) između korisničkih programa i jezgre operacijskog sustava. Omogućuju korisničkim programima da traže usluge od jezgre, poput čitanja datoteka, upravljanja memorijom i procesa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 449,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koja je razlika između jezgrenog i korisničkog načina rada?",
    "answer": "Korisnički način rada (privilegijska razina 3) ograničava pristup hardveru i resursima sustava, dok jezgreni način rada (privilegijska razina 0) ima puni pristup sustavu. Sistemski pozivi omogućuju sigurnu komunikaciju između ta dva načina.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 450,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako funkcionira izvršavanje sistemskog poziva?",
    "answer": "Izvršava se ASM instrukcija syscall, koja prebacuje program iz korisničkog u jezgreni način rada. Identifikacijski broj željenog sistemskog poziva postavlja se u eax registar, a zatim se koristi tablica sistemskih poziva kako bi se pronašao odgovarajući handler na fiksnoj adresi.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 451,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je system call handler?",
    "answer": "To je dio jezgre operacijskog sustava koji prima i obrađuje sistemski poziv kada dođe iz korisničkog načina rada.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 452,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako su sistemski pozivi implementirani u Linuxu?",
    "answer": "Linux koristi syscall instrukciju za pozivanje funkcija iz jezgre. Svakom pozivu dodijeljen je jedinstveni broj koji se koristi za pronalaženje funkcije u tablici sistemskih poziva.",
    "link": "https://filippo.io/linux-syscall-table/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 453,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Zašto je pristup sistemskim pozivima drugačiji na Windowsima?",
    "answer": "Kod Windowsa izvorni kod jezgre nije javno dostupan pa se sistemski pozivi ne mogu direktno inspektirati. Umjesto toga, dostupna je dokumentacija za Win32 API koji omogućuje razvoj softvera za Windows bez direktnog uvida u sistemske pozive.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 454,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je proces?",
    "answer": "Proces je instanca računalnog programa u izvođenju. Svaki proces koristi vlastite resurse poput CPU-a, memorije, datoteka i I/O uređaja. Čak i ako dva procesa izvršavaju isti program, oni su međusobno nezavisni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 455,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koje su osnovne odgovornosti operacijskog sustava vezane uz procese?",
    "answer": "Operacijski sustav je odgovoran za kreiranje i brisanje korisničkih i sistemskih procesa, za njihovo raspoređivanje odnosno scheduling, te za osiguravanje mehanizama kojima se upravlja međusobnom sinkronizacijom, komunikacijom među procesima i zastojima koji mogu nastati.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 456,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako izgleda struktura procesa u memoriji?",
    "answer": "Struktura procesa u memoriji podijeljena je u nekoliko dijelova. Stog se koristi za privremene podatke poput parametara funkcija, povratnih adresa i lokalnih varijabli. Hrpa je dio memorije koji se dinamički alocira tijekom izvršavanja procesa. Podatkovni dio sadrži globalne i statičke varijable, dok tekstualni dio sadrži izvršni kod programa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 457,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je Process Control Block?",
    "answer": "Process Control Block, skraćeno PCB, je podatkovna struktura koja čuva sve važne informacije o procesu. Te informacije uključuju jedinstveni identifikacijski broj procesa (Process ID), adresu sljedeće instrukcije koja će se izvršiti (Program Counter), informacije o korištenju ulazno-izlaznih uređaja, podatke za raspoređivanje procesa poput prioriteta i pokazivača na redove čekanja te statističke podatke o korištenju CPU-a i vremenskim ograničenjima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 458,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja su osnovna stanja procesa?",
    "answer": "Osnovna stanja procesa uključuju stanja u kojima se proces može nalaziti tijekom svog životnog ciklusa, a to su: novo (new), spremno (ready), u izvođenju (running), u čekanju (waiting) i završeno (terminated). Svaki proces prelazi iz jednog stanja u drugo ovisno o događajima tijekom svog izvođenja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 459,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što se događa kada proces primi signal?",
    "answer": "Kada proces primi signal, on može reagirati na nekoliko načina. Može ignorirati signal, iako neki signali ne mogu biti ignorirani. Također može izvršiti zadanu, unaprijed definiranu radnju, ili može izvršiti vlastitu, prilagođenu funkciju koja obrađuje taj signal. Ta se funkcija naziva signal handler. Jezgra tada obavlja zamjenu konteksta kako bi pozvala handler, a nakon njegovog izvršavanja, kontrola se vraća izvornom procesu.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 460,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako izgleda hijerarhija procesa u Linuxu?",
    "answer": "U Linux operacijskom sustavu, prvi proces koji se pokreće je proces pod nazivom init i ima identifikacijski broj PID=1. Taj proces je uvijek u stanju izvršavanja i svi ostali procesi se smatraju njegovom djecom ili potomcima. Svaki proces u sustavu ima svog roditelja, a može imati i više \"braće i sestara\", odnosno druge procese koje je stvorio isti roditeljski proces. Djeca također mogu stvarati vlastitu djecu, čime nastaje hijerarhijska struktura procesa. Uz init postoje i alternativni sustavi za pokretanje procesa, poput systemd-a, Upstarta, OpenRC-a, Epocha i Mudara.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 461,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Zašto se koristi višedretvenost?",
    "answer": "Višedretvenost se koristi kako bi se omogućilo izvođenje više neovisnih tokova instrukcija istovremeno, pri čemu te dretve dijele zajednički adresni prostor. Time se postiže paralelizam dijeljenjem jednog procesa na više dretvi, što povećava učinkovitost i iskorištenost procesora.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 462,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koja je razlika između procesa i dretvi?",
    "answer": "Procesi su izolirani jedni od drugih i koriste zaseban memorijski prostor, dok dretve dijele zajednički memorijski prostor i ovise jedna o drugoj. Stvaranje i komunikacija među procesima imaju veći vremenski trošak (overhead), dok su dretve lakše (lightweight) i brže u komunikaciji. Također, pogreške u jednom procesu ne utječu na druge procese, dok greška u jednoj dretvi može utjecati na sve ostale dretve unutar istog procesa. Kod dretvi je zbog dijeljenja resursa potrebna sinkronizacija, dok kod procesa to često nije slučaj.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 463,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koja je razlika između programa s jednom dretvom i programa s više dretvi?",
    "answer": "Program s jednom dretvom izvršava sve zadatke sekvencijalno, što može uzrokovati blokiranje cijelog programa ako dođe do zahtjevne operacije. S druge strane, program s više dretvi omogućava da se pojedini dijelovi aplikacije izvode paralelno, čime se poboljšava responzivnost i ukupna učinkovitost.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 464,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koje su prednosti korištenja dretvi?",
    "answer": "Korištenje dretvi omogućava bolju responzivnost programa jer se kompleksni zahtjevi mogu izvršavati bez blokiranja drugih dijelova aplikacije. Također se smanjuje vrijeme potrebno za prebacivanje konteksta, jer je manji overhead nego kod procesa. Komunikacija između dretvi je jednostavnija i učinkovitija jer dijele memorijski prostor. Osim toga, dretve poboljšavaju skalabilnost jer omogućuju iskorištavanje paralelizma u višeprocesorskim sustavima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 465,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koje vrste dretvi postoje?",
    "answer": "Postoje dvije glavne vrste dretvi: korisničke (user threads) i jezgrene (kernel threads). Korisničke dretve implementirane su u korisničkom prostoru bez izravne podrške jezgre i obično su jednostavne za implementaciju. Jezgrene dretve podržava sama jezgra operacijskog sustava i omogućuju izvođenje više zadataka paralelno na razini jezgre, ali njihova implementacija je složenija.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 466,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Kako se korisničke dretve mapiraju na jezgrene dretve?",
    "answer": "Korisničke dretve mogu se mapirati na jezgrene dretve koristeći jednu od tri strategije: „many to one“, gdje više korisničkih dretvi koristi jednu jezgrenu dretvu; „one to one“, gdje svaka korisnička dretva ima svoju jezgrenu dretvu; te „many to many“, gdje više korisničkih dretvi može koristiti više jezgrenih dretvi, ali ne nužno u omjeru jedan na jedan.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 467,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Što je utrkivanje  i kada nastaje?",
    "answer": "Utrkivanje nastaje kada više dretvi istovremeno pokušava pristupiti i mijenjati zajedničke resurse, a redoslijed izvršavanja tih operacija nije definiran. To dovodi do neočekivanih ponašanja programa ili pogrešnih rezultata. Utrkivanje se obično događa u kritičnim sekcijama koda gdje se provode operacije tipa \"read-modify-write\" ili \"check-then-act\".",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 468,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Što je sinkronizacija i kako pomaže kod upravljanja dretvama?",
    "answer": "Sinkronizacija je mehanizam koji rješava probleme poput utrkivanja među dretvama. Uključuje korištenje atomskih operacija, semafora i međusobnog isključivanja (mutex). ",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 469,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Kako radi mutex?",
    "answer": "Mutex radi slično binarnom semaforu, ali se temelji na zaključavanju resursa kako bi se osiguralo da samo jedna dretva u određenom trenutku ima pristup kritičnoj sekciji.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 470,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što je međuprocesna komunikacija?",
    "answer": "Međuprocesna komunikacija (IPC) je mehanizam koji operacijski sustav pruža kako bi procesi mogli međusobno komunicirati i upravljati dijeljenim resursima. Omogućuje sinkronizaciju i razmjenu podataka među procesima koji se izvršavaju istovremeno.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 471,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira komunikacija putem dijeljene memorije?",
    "answer": "Komunikacija putem dijeljene memorije podrazumijeva pisanje i čitanje podataka u zajednički memorijski prostor. Procesi koji koriste dijeljenu memoriju odmah vide promjene, što čini ovu metodu najbržom. Međutim, zahtijeva pažljivo upravljanje pristupom pomoću semafora kako bi se izbjegli problemi istovremenog pristupa, slično kao u višedretvenim programima.",
    "link": "https://www.geeksforgeeks.org/inter-process-communication-ipc-shared-memory/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 472,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što je memorijsko mapiranje i kako se koristi u IPC-u?",
    "answer": "Memorijsko mapiranje omogućuje procesima da komuniciraju putem datoteka koje su mapirane u njihovu memoriju. Operacijski sustav upravlja pristupom datotekama, a procesi tretiraju mapirani dio kao da je dio njihove glavne memorije. Promjene u memoriji automatski se prenose u povezane datoteke.",
    "link": "https://learn.microsoft.com/en-us/windows/win32/memory/creating-a-file-mapping-object"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 473,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira cjevovod u međuprocesnoj komunikaciji?",
    "answer": "Cjevovod je jednosmjeran kanal između dva procesa. Jedan proces upisuje podatke, dok drugi čita. Najčešće se koristi između povezanih procesa, poput roditeljskog i podprocesa. Cjevovod postoji samo dok su povezani procesi aktivni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 474,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Po čemu se imenovani cjevovod razlikuje od običnog cjevovoda?",
    "answer": "Imenovani cjevovod (FIFO) ima ime u datotečnom sustavu, što omogućuje komunikaciju i između nepovezanih procesa. Procesi mogu neovisno otvarati, zatvarati, čitati i pisati u FIFO.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 475,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira komunikacija porukama?",
    "answer": "Komunikacija porukama omogućuje slanje i primanje poruka putem redova poruka. Poruke se obično obrađuju redoslijedom dolaska, ali postoji mogućnost da se pojedine poruke ciljano povuku prije nego dođu na red, što pruža veću fleksibilnost od FIFO.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 476,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što su signali i kako se koriste u IPC-u?",
    "answer": "Signali su oblik softverskih prekida koje procesi koriste za obavještavanje drugih procesa o određenim događajima. Signale može slati drugi proces ili jezgra sustava. Kad proces primi signal, može izvršiti određenu funkciju poznatu kao signalni rukovatelj (handler).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 477,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Koji oblik međuprocesne komunikacije će biti obrađen sljedeći tjedan?",
    "answer": "Sljedeći tjedan planira se obrada IPC-a putem utičnica (sockets), koje omogućuju komunikaciju između procesa na različitim računalima putem mreže.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 478,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Što su utičnice u kontekstu međuprocesne komunikacije?",
    "answer": "Utičnice su mehanizam koji omogućuje međuprocesnu komunikaciju između više procesa na istom računalu ili između računala unutar iste mreže. Podaci se šalju u obliku paketa, a najčešće se koristi model poslužitelj-klijent. Utičnice omogućuju fleksibilan i standardiziran način komunikacije putem mreže.",
    "link": "https://en.wikipedia.org/wiki/Network_socket"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 479,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koje je tri stvari potrebno definirati prilikom stvaranja socket-a?",
    "answer": "Prilikom stvaranja socket-a potrebno je definirati stil komunikacije, namespace i protokol. Stil komunikacije određuje način na koji se podaci prenose, namespace određuje adresni prostor i način na koji se socket identificira, a protokol definira pravila prijenosa podataka između krajnjih točaka komunikacije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 480,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koje su osnovne razlike između stream i datagram utičnica?",
    "answer": "Stream utičnice predstavljaju oblik komunikacije koji je pouzdan i osigurava da svi paketi stignu na odredište redoslijedom kojim su poslani. Ako neki paket ne stigne, automatski se ponovno šalje, što omogućuje točnu i sigurnu isporuku podataka. Takav način rada nalikuje TCP protokolu. S druge strane, datagram utičnice ne garantiraju isporuku paketa niti njihov redoslijed, već se fokusiraju na brzinu prijenosa. U slučaju gubitka paketa, nema ponovnog slanja. Ovakav način rada podsjeća na UDP komunikaciju, gdje je brzina prioritet nad pouzdanošću.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 481,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Što predstavlja namespace kod socket-a?",
    "answer": "Namespace kod socket-a predstavlja način na koji se adresira jedna krajnja točka komunikacije. Ako se koristi lokalni namespace, adresa se odnosi na datoteku u datotečnom sustavu, čime se socket identificira pomoću imena datoteke. Ako se koristi mrežni namespace, adresa socket-a sastoji se od IP adrese hosta i broja porta, čime se omogućuje komunikacija između udaljenih računala preko mreže.",
    "link": "https://en.wikipedia.org/wiki/Unix_domain_socket"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 482,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koju ulogu ima protokol kod socket-a?",
    "answer": "Protokol kod socket-a određuje način na koji će se podaci prenositi između procesa. On definira pravila komunikacije i ponašanje tijekom razmjene informacija. Neki od najčešće korištenih protokola su TCP/IP, koji osigurava pouzdan prijenos podataka, i UDP, koji omogućuje brži ali manje pouzdan prijenos. Osim mrežnih protokola, za lokalnu komunikaciju koristi se i UNIX lokalni protokol, dok se u specifičnim okruženjima može naići na starije protokole poput AppleTalk-a.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 483,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koji su osnovni sistemski pozivi pri radu sa socket-ima?",
    "answer": "Pri radu sa socket-ima koristi se niz sistemskih poziva koji omogućuju stvaranje i upravljanje socket-ima. Proces započinje stvaranjem socket-a pomoću poziva socket, nakon čega se socket povezuje s adresom pomoću bind ako se radi o poslužitelju. Potom se socket stavlja u stanje slušanja s pozivom listen, a klijent koristi connect kako bi uspostavio vezu. Kada poslužitelj primi zahtjev, koristi accept za prihvaćanje veze. Za razmjenu podataka koriste se read i write, dok se na kraju veze socket zatvara pozivom close.",
    "link": "https://en.wikipedia.org/wiki/Berkeley_sockets"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 484,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je upravljanje memorijom?",
    "answer": "Upravljanje memorijom je funkcionalnost operacijskog sustava kojom se omogućuje učitavanje više procesa u radnu memoriju i raspoređivanje te memorije među njima. Operacijski sustav vodi računa o tome koji dijelovi memorije su zauzeti, koji su slobodni, i kako optimalno dodijeliti memorijske resurse svakom procesu tako da se postigne učinkovito korištenje memorije i izbjegnu konflikti među procesima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 485,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji su problemi povezani s fiksnim particioniranjem memorije?",
    "answer": "Kod fiksnog particioniranja memorije, ukupna memorija podijeljena je na unaprijed definirane blokove fiksne veličine. Glavni problem ovog pristupa je unutarnja fragmentacija, koja nastaje kada proces zauzme više memorije nego što mu je stvarno potrebno, ali se svejedno dodjeljuje cijeli blok. Zbog toga dolazi do neučinkovitog korištenja memorije, a dodatni problem je i ograničen broj procesa koji mogu istovremeno biti aktivni, jer broj particija definira maksimalan broj procesa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 486,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji je glavni problem dinamičkog particioniranja memorije?",
    "answer": "Glavni problem kod dinamičkog particioniranja memorije je vanjska fragmentacija. To se događa kada tijekom vremena u memoriji nastanu brojni mali, nepovezani slobodni prostori koji zajedno možda čine dovoljno memorije za novi proces, ali zbog njihove razdvojenosti operacijski sustav ne može alocirati memoriju u jednom komadu. Zbog toga može doći do situacije u kojoj se novi proces ne može učitati, iako ukupno ima dovoljno slobodne memorije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 487,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je zbijanje memorije i kada se koristi?",
    "answer": "Zbijanje memorije je postupak kojim operacijski sustav premješta podatke u memoriji s ciljem uklanjanja vanjske fragmentacije. Premještanjem aktivnih procesa u jedan dio memorije, oslobađa se kontinuirani blok memorije koji se može dodijeliti novim procesima. Ova operacija povećava učinkovitost korištenja memorije, ali također predstavlja dodatni trošak za sustav jer zahtijeva vrijeme i resurse za pomicanje podataka.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 488,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji algoritmi se koriste za dodjelu slobodnih memorijskih blokova?",
    "answer": "Postoji nekoliko algoritama koji se koriste za odabir slobodnih blokova memorije kada novi proces zatraži prostor. Prvi algoritam, First-fit, traži prvi dovoljno veliki blok i odmah ga dodjeljuje. Next-fit je sličan, ali nastavlja pretraživanje od mjesta gdje je prethodna alokacija završila. Best-fit traži najmanji blok koji je dovoljno velik za proces, kako bi se ostavilo što manje neiskorištenog prostora. Suprotno tome, Worst-fit odabire najveći dostupni blok, s namjerom da podijeljeni ostatak nakon alokacije bude dovoljno velik za buduće zahtjeve. Svaki od ovih algoritama ima svoje prednosti i nedostatke u pogledu brzine i količine fragmentacije koju uzrokuje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 489,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je buddy system i kako funkcionira?",
    "answer": "„Buddy system“ je metoda upravljanja memorijom koja predstavlja kompromis između fiksnog i dinamičkog particioniranja. U ovom sustavu, memorija se dijeli na blokove veličine koji su potencije broja dva, a kada je potrebno, veći blokovi se dijele na manje. Ako su dva susjedna bloka slobodna i imaju istu veličinu, oni se mogu ponovno spojiti u veći blok. Ovaj sustav omogućuje fleksibilnu i učinkovitu dodjelu memorije uz smanjenu fragmentaciju i brže pronalaženje slobodnog prostora.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 490,
  "fields": {
    "lecture_id": 13,
    "subject": 3,
    "question": "Koji su osnovni sigurnosni zahtjevi i sigurnosne prijetnje u informacijskim sustavima?",
    "answer": "Sigurnosni zahtjevi informacijskih sustava temelje se na četiri ključna principa: povjerljivosti, integritetu, dostupnosti i autentičnosti. Povjerljivost podrazumijeva da su podaci dostupni samo ovlaštenim osobama, a ne smiju ih presresti treće strane, što se naziva presretanjem. Integritet znači da podaci ostaju neizmijenjeni osim ako ih ne izmijeni netko s odgovarajućim ovlastima, a svako neautorizirano mijenjanje predstavlja sigurnosnu prijetnju poznatu kao modifikacija. Dostupnost osigurava da sustav i njegovi resursi budu dostupni korisnicima kad god su im potrebni, dok je prekid rada ili pristupa sustavu prijetnja koja ugrožava dostupnost. Autentičnost se odnosi na vjerodostojnost komunikacije ili identiteta korisnika, a sigurnosna prijetnja koja ugrožava autentičnost naziva se fabrikacija, jer uključuje lažno predstavljanje ili izmišljanje podataka.",
    "link": "https://ocw.mit.edu/courses/6-858-computer-systems-security-fall-2014/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 491,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je zastoj?",
    "answer": "Procesi međusobno čekaju resurse koje drže drugi procesi, stvarajući kružno čekanje bez izlaza.",
    "link": "https://www.geeksforgeeks.org/introduction-of-deadlock-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 492,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koji su primjeri iz stvarnog svijeta za zastoj?",
    "answer": "Uski tunel: dva automobila koja dolaze s različitih strana ne mogu proći istovremeno.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 493,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koja su četiri nužna uvjeta za nastanak zastoja?",
    "answer": "Međusobno isključivanje, zadrži i čekaj, nema iznuđivanja, kružno čekanje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 494,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Je li dovoljno da 4 glavna uvijeta zadovoljena da se zastoj dogodi?",
    "answer": "procesi međusobno čekaju resurse koje drže drugi procesi, stvarajući kružno čekanje bez izlaza.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 495,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako nastaje zastoj kod semafora?",
    "answer": " Kada procesi koriste semafore u različitom redoslijedu: P1- wait(S); wait(Q) i P2- wait(Q); wait(S);",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 496,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako dolazi do zastoja kod memorije?",
    "answer": "Kad procesi traže više memorije u fazama koje se međusobno blokiraju.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 497,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako komunikacija može uzrokovati zastoj?",
    "answer": "Ako proces A čeka poruku od procesa B, a B čeka poruku od A.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 498,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je dijagram dodjeljivanja resursa?",
    "answer": "Graf s čvorovima za procese i resurse, gdje strelice označavaju zahtjeve i dodjele.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 499,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako prepoznati zastoj u grafu?",
    "answer": "Ako postoji kružni put, postoji potencijalni zastoj.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 500,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako se može spriječiti zastoj?",
    "answer": "Onemogućavanjem barem jednog od uvjeta: 1. Zabraniti „zadrži i čekaj“, 2. Dozvoliti iznuđivanje, 3. Izbjegavati kružno čekanje poretkom resursa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 501,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Zašto je sprječavanje zastoja nepraktično?",
    "answer": "Često je neefikasno i može dovesti do lošeg iskorištavanja resursa",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 502,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je Bankarov algoritam?",
    "answer": "Algoritam koji simulira dodjelu resursa i provjerava da li sustav ostaje u sigurnom stanju.",
    "link": "https://www.geeksforgeeks.org/bankers-algorithm-in-operating-system-2/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 503,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kada se zahtjev za resursom odbija prema Bankarovu algoritmu?",
    "answer": "Ako proces traži više od prijavljenog maksimuma ili ako sustav ulazi u nesigurno stanje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 504,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako operacijski sustav otkriva zastoj?",
    "answer": "Periodičkom provjerom grafa dodjele resursa pomoću algoritma za otkrivanje zastoja.",
    "link": "https://www.geeksforgeeks.org/deadlock-detection-algorithm-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 505,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako znati koji su procesi u zastoju?",
    "answer": "Procesi koji na kraju algoritma ostanu neoznačeni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 506,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako se može riješiti zastoj?",
    "answer": "Zastoj se može riješiti: prekidom procesa, rollbackom procesa ili iznuđivanjem resursa",
    "link": "https://www.geeksforgeeks.org/deadlock-handling-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 507,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koji je kriterij za odabir procesa za prekid?",
    "answer": "Prioritet, vrsta procesa, količina resursa koje koristi i broj prethodnih rollbackova",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 508,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je kombinirani pristup upravljanju zastojima?",
    "answer": "Kombinacija prevencije, izbjegavanja i otkrivanja, ovisno o vrsti resursa i efikasnosti.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 509,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je uloga upravljanja memorijom u operacijskom sustavu?",
    "answer": "Upravljanje memorijom omogućuje učitavanje više procesa u memoriju, njihovu zaštitu, dijeljenje memorije i učinkovito korištenje resursa. Također omogućuje logičku i fizičku separaciju memorijskih adresa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 510,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koje su glavne faze povezivanja adresa u memoriji?",
    "answer": "Povezivanje adresa može se vršiti: 1. Tijekom prevođenja(compile time), 2.prilikom učitavanja(load time), 3. za vrijeme izvršavanja(execution time), gdje je potrebna hardverska podrška (base i limit registri)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 511,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je dinamičko punjenje?",
    "answer": "Potprogrami i funkcije se učitavaju u memoriju samo kad se pozovu, čime se smanjuje iskorištenost memorije jer se učitavaju samo stvarno korištene funkcije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 512,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja je razlika između statičkog i dinamičkog povezivanja?",
    "answer": "Statičko povezivanje uključuje sistemske knjižnice pri kompilaciji, dok se dinamičko povezivanje obavlja tijekom izvođenja i omogućuje dijeljenje koda među procesima.",
    "link": "https://www.geeksforgeeks.org/static-and-dynamic-linking-in-operating-systems/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 513,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koji su osnovni zahtjevi upravljanja memorijom?",
    "answer": "Premještanje (relocation), zaštita (protection), dijeljenje (sharing), logička i fizička organizacija memorije",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 514,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je Memory Management Unit?",
    "answer": "MMU je sklop koji pretvara logičke (virtualne) adrese u fizičke, često pomoću base i limit registara. Time se omogućuje izolacija između procesa i fleksibilnije upravljanje memorijom.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 515,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je prebacivanje u kontekstu memorije?",
    "answer": "Proces se može privremeno ukloniti iz glavne memorije i smjestiti u sekundarnu memoriju da bi se oslobodilo mjesto za druge procese. Kasnije se može vratiti za nastavak izvršavanja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 516,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koji su problemi fiksnog particioniranja memorije?",
    "answer": "Glavni problem je unutarnja fragmentacija, jer svaki proces zauzima cijelu particiju, bez obzira na stvarnu veličinu.",
    "link": "https://www.geeksforgeeks.org/difference-between-internal-and-external-fragmentation/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 517,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je vanjska fragmentacija i kako se rješava?",
    "answer": "Vanjska fragmentacija nastaje kad postoji dovoljno ukupne slobodne memorije, ali ne u jednom komadu. Rješava se zbijanjem memorije (compaction).",
    "link": "https://www.geeksforgeeks.org/difference-between-internal-and-external-fragmentation/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 518,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je buddy system?",
    "answer": "To je sustav za dinamičku dodjelu memorije u blokovima veličine 2^k. Kad se memorija oslobodi, blokovi se mogu spajati ako su „parovi” (buddies).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 519,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako funkcionira straničenje?",
    "answer": "Straničenje dijeli memoriju na jednake blokove (stranice i okvire - frames). Proces koristi tablicu stranica za preslikavanje virtualnih adresa u fizičke.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 520,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Čemu služi Translation Lookaside Buffer?",
    "answer": "TLB je cache koji pohranjuje nedavno korištene preslikavanja stranica, čime ubrzava pristup memoriji izbjegavajući stalne pristupe glavnoj memoriji.",
    "link": "https://www.geeksforgeeks.org/translation-lookaside-buffer-tlb-in-paging/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 521,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je segmentacija u upravljanju memorijom?",
    "answer": "Segmentacija omogućuje logičku podjelu programa na segmente (npr. kod, podaci), različitih veličina, s posebnim pravima pristupa i vidljivim programeru.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 522,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja je razlika između straničenja i segmentacije?",
    "answer": "Straničenje koristi fiksne veličine stranica i nevidljivo je programeru. Segmentacija koristi varijabilne veličine segmenata i vidljiva je programeru. Obje se mogu kombinirati.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 523,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je virtualna memorija i kako funkcionira?",
    "answer": "Virtualna memorija omogućuje da proces koristi više memorije nego što fizički postoji, učitavanjem samo potrebnih dijelova u glavnu memoriju prema potrebi.",
    "link": "https://www.geeksforgeeks.org/virtual-memory-in-operating-system/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 524,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je računalna sigurnost i zašto je važna?",
    "answer": "Računalna sigurnost odnosi se na zaštitu računalnih sustava i podataka od neovlaštenog pristupa, oštećenja ili krađe. U informatičkom dobu, gdje su informacije temelj modernog načina života, sigurnost je ključna za očuvanje povjerljivosti, integriteta i dostupnosti podataka.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 525,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koji su osnovni sigurnosni zahtjevi računalnih sustava?",
    "answer": "Osnovni sigurnosni zahtjevi uključuju: Povjerljivost: samo autorizirani korisnici imaju pristup informacijama, Integritet: samo auzorizirani korisnici mogu mijenjati informacije, Dostupnost: informacije moraju biti dostupne autoriziranim korisnicima, Autentičnost: sustav provjerava valjanost indentiteta subjeka",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 526,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je Denial of Service napad?",
    "answer": "DoS napad je pokušaj onemogućavanja pristupa servisu ili sustavu zakonitim korisnicima, često preopterećenjem resursa. Distribuirani DoS (DDoS) napadi koriste više kompromitiranih uređaja za izvođenje napada.",
    "link": "https://stytch.com/blog/10-common-cyber-attacks"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 527,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koji su najčešći oblici zlonamjernog softvera?",
    "answer": "Najčešći oblici uključuju: Spyware: Prikuplja informacije bez znanja korisnika, Keylogger: Bilježi pritiske tipki kako bi ukrao lozinke i druge osjetljive podatke, Dialer: Automatski bira brojeve, često skupe, bez znanja korisnika, Rootkit: Omogućuje neautorizirani pristup sustavu skrivajući se od detekcije",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 528,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Kako se možemo obraniti od sigurnosnih prijetnji?",
    "answer": "Edukacija korisnika, redovite sigurnosne kopije(backup), implementacija sigurnosnih politika, korištenje jakih lozinki i njihovo redovito mijenjanje, ažuriranje sustava i softvera, korištenje kriptografije, primjena vatrozida (firewall) i VPN-a, korištenje antivirusnih programa i sustava za otkrivanje upada (IDS)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 529,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je kriptografija i koje su osnovne metode šifriranja?",
    "answer": "Kriptografija je znanost o zaštiti informacija pretvaranjem čitljivih podataka u neprepoznatljiv oblik. Simetično šifriranje: isti ključ se koristi za šifriranje i dešifriranje podataka, Asimetrično šifriranje: koriste se dva različita ključa - javni za šifriranje i privatni za dešifriranje",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 530,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Zašto su lozinke važan aspekt sigurnosti i kako ih pravilno koristiti?",
    "answer": " Lozinke su prva linija obrane u zaštiti računalnih sustava. Dobra lozinka treba biti kompleksna, jedinstvena i redovito mijenjana. Također, važno je ne dijeliti lozinke i koristiti upravitelje lozinki za njihovo sigurno pohranjivanje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 531,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je dvofaktorska autentifikacija i kako poboljšava sigurnost?",
    "answer": "2FA dodaje dodatni sloj sigurnosti zahtijevajući dva oblika identifikacije prije pristupa sustavu: Nnešto što korisnik zna npr. lozinka ili PIN ili nešto što korisnik ima kao npr. mobilni uređaj, token ili biometrijski podatak",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 532,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Kako socijalni inženjering predstavlja prijetnju sigurnosti?",
    "answer": "Socijalni inženjering manipulira ljudima kako bi otkrili povjerljive informacije. Primjeri uključuju phishing napade, lažne pozive ili poruke koje se predstavljaju kao legitimne kako bi prevarili korisnike.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 533,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Koje su preporuke za zaštitu od phishing napada?",
    "answer": "Preporuke su: pažljivo provjeravanje e-mail adresa i linkova, ne otvaranje sumnjivih privitaka, korištenje sigurnosnih alata koji detektiraju phising pokušaje, edukacija korisnika o prepoznavanju lažnih poruka",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 534,
  "fields": {
    "lecture_id": 8,
    "subject": 3,
    "question": "Što je sigurnosna politika i zašto je važna?",
    "answer": "Sigurnosna politika je skup pravila i procedura koje organizacija uspostavlja kako bi zaštitila svoje informacijske resurse. Ona definira odgovornosti, dopuštenja i postupke u slučaju sigurnosnih incidenata.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 535,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što su sistemski pozivi?",
    "answer": "Sistemski pozivi su sučelje (API) između korisničkih programa i jezgre operacijskog sustava. Omogućuju korisničkim programima da traže usluge od jezgre, poput čitanja datoteka, upravljanja memorijom i procesa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 536,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Koja je razlika između jezgrenog i korisničkog načina rada?",
    "answer": "Korisnički način rada (privilegijska razina 3) ograničava pristup hardveru i resursima sustava, dok jezgreni način rada (privilegijska razina 0) ima puni pristup sustavu. Sistemski pozivi omogućuju sigurnu komunikaciju između ta dva načina.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 537,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako funkcionira izvršavanje sistemskog poziva?",
    "answer": "Izvršava se ASM instrukcija syscall, koja prebacuje program iz korisničkog u jezgreni način rada. Identifikacijski broj željenog sistemskog poziva postavlja se u eax registar, a zatim se koristi tablica sistemskih poziva kako bi se pronašao odgovarajući handler na fiksnoj adresi.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 538,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Što je system call handler?",
    "answer": "To je dio jezgre operacijskog sustava koji prima i obrađuje sistemski poziv kada dođe iz korisničkog načina rada.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 539,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Kako su sistemski pozivi implementirani u Linuxu?",
    "answer": "Linux koristi syscall instrukciju za pozivanje funkcija iz jezgre. Svakom pozivu dodijeljen je jedinstveni broj koji se koristi za pronalaženje funkcije u tablici sistemskih poziva.",
    "link": "https://filippo.io/linux-syscall-table/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 540,
  "fields": {
    "lecture_id": 6,
    "subject": 3,
    "question": "Zašto je pristup sistemskim pozivima drugačiji na Windowsima?",
    "answer": "Kod Windowsa izvorni kod jezgre nije javno dostupan pa se sistemski pozivi ne mogu direktno inspektirati. Umjesto toga, dostupna je dokumentacija za Win32 API koji omogućuje razvoj softvera za Windows bez direktnog uvida u sistemske pozive.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 541,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je proces?",
    "answer": "Proces je instanca računalnog programa u izvođenju. Svaki proces koristi vlastite resurse poput CPU-a, memorije, datoteka i I/O uređaja. Čak i ako dva procesa izvršavaju isti program, oni su međusobno nezavisni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 542,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koje su osnovne odgovornosti operacijskog sustava vezane uz procese?",
    "answer": "Operacijski sustav je odgovoran za kreiranje i brisanje korisničkih i sistemskih procesa, za njihovo raspoređivanje odnosno scheduling, te za osiguravanje mehanizama kojima se upravlja međusobnom sinkronizacijom, komunikacijom među procesima i zastojima koji mogu nastati.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 543,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako izgleda struktura procesa u memoriji?",
    "answer": "Struktura procesa u memoriji podijeljena je u nekoliko dijelova. Stog se koristi za privremene podatke poput parametara funkcija, povratnih adresa i lokalnih varijabli. Hrpa je dio memorije koji se dinamički alocira tijekom izvršavanja procesa. Podatkovni dio sadrži globalne i statičke varijable, dok tekstualni dio sadrži izvršni kod programa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 544,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što je Process Control Block?",
    "answer": "Process Control Block, skraćeno PCB, je podatkovna struktura koja čuva sve važne informacije o procesu. Te informacije uključuju jedinstveni identifikacijski broj procesa (Process ID), adresu sljedeće instrukcije koja će se izvršiti (Program Counter), informacije o korištenju ulazno-izlaznih uređaja, podatke za raspoređivanje procesa poput prioriteta i pokazivača na redove čekanja te statističke podatke o korištenju CPU-a i vremenskim ograničenjima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 545,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Koja su osnovna stanja procesa?",
    "answer": "Osnovna stanja procesa uključuju stanja u kojima se proces može nalaziti tijekom svog životnog ciklusa, a to su: novo (new), spremno (ready), u izvođenju (running), u čekanju (waiting) i završeno (terminated). Svaki proces prelazi iz jednog stanja u drugo ovisno o događajima tijekom svog izvođenja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 546,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Što se događa kada proces primi signal?",
    "answer": "Kada proces primi signal, on može reagirati na nekoliko načina. Može ignorirati signal, iako neki signali ne mogu biti ignorirani. Također može izvršiti zadanu, unaprijed definiranu radnju, ili može izvršiti vlastitu, prilagođenu funkciju koja obrađuje taj signal. Ta se funkcija naziva signal handler. Jezgra tada obavlja zamjenu konteksta kako bi pozvala handler, a nakon njegovog izvršavanja, kontrola se vraća izvornom procesu.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 547,
  "fields": {
    "lecture_id": 7,
    "subject": 3,
    "question": "Kako izgleda hijerarhija procesa u Linuxu?",
    "answer": "U Linux operacijskom sustavu, prvi proces koji se pokreće je proces pod nazivom init i ima identifikacijski broj PID=1. Taj proces je uvijek u stanju izvršavanja i svi ostali procesi se smatraju njegovom djecom ili potomcima. Svaki proces u sustavu ima svog roditelja, a može imati i više \"braće i sestara\", odnosno druge procese koje je stvorio isti roditeljski proces. Djeca također mogu stvarati vlastitu djecu, čime nastaje hijerarhijska struktura procesa. Uz init postoje i alternativni sustavi za pokretanje procesa, poput systemd-a, Upstarta, OpenRC-a, Epocha i Mudara.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 548,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Zašto se koristi višedretvenost?",
    "answer": "Višedretvenost se koristi kako bi se omogućilo izvođenje više neovisnih tokova instrukcija istovremeno, pri čemu te dretve dijele zajednički adresni prostor. Time se postiže paralelizam dijeljenjem jednog procesa na više dretvi, što povećava učinkovitost i iskorištenost procesora.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 549,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koja je razlika između procesa i dretvi?",
    "answer": "Procesi su izolirani jedni od drugih i koriste zaseban memorijski prostor, dok dretve dijele zajednički memorijski prostor i ovise jedna o drugoj. Stvaranje i komunikacija među procesima imaju veći vremenski trošak (overhead), dok su dretve lakše (lightweight) i brže u komunikaciji. Također, pogreške u jednom procesu ne utječu na druge procese, dok greška u jednoj dretvi može utjecati na sve ostale dretve unutar istog procesa. Kod dretvi je zbog dijeljenja resursa potrebna sinkronizacija, dok kod procesa to često nije slučaj.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 550,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koja je razlika između programa s jednom dretvom i programa s više dretvi?",
    "answer": "Program s jednom dretvom izvršava sve zadatke sekvencijalno, što može uzrokovati blokiranje cijelog programa ako dođe do zahtjevne operacije. S druge strane, program s više dretvi omogućava da se pojedini dijelovi aplikacije izvode paralelno, čime se poboljšava responzivnost i ukupna učinkovitost.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 551,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koje su prednosti korištenja dretvi?",
    "answer": "Korištenje dretvi omogućava bolju responzivnost programa jer se kompleksni zahtjevi mogu izvršavati bez blokiranja drugih dijelova aplikacije. Također se smanjuje vrijeme potrebno za prebacivanje konteksta, jer je manji overhead nego kod procesa. Komunikacija između dretvi je jednostavnija i učinkovitija jer dijele memorijski prostor. Osim toga, dretve poboljšavaju skalabilnost jer omogućuju iskorištavanje paralelizma u višeprocesorskim sustavima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 552,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Koje vrste dretvi postoje?",
    "answer": "Postoje dvije glavne vrste dretvi: korisničke (user threads) i jezgrene (kernel threads). Korisničke dretve implementirane su u korisničkom prostoru bez izravne podrške jezgre i obično su jednostavne za implementaciju. Jezgrene dretve podržava sama jezgra operacijskog sustava i omogućuju izvođenje više zadataka paralelno na razini jezgre, ali njihova implementacija je složenija.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 553,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Kako se korisničke dretve mapiraju na jezgrene dretve?",
    "answer": "Korisničke dretve mogu se mapirati na jezgrene dretve koristeći jednu od tri strategije: „many to one“, gdje više korisničkih dretvi koristi jednu jezgrenu dretvu; „one to one“, gdje svaka korisnička dretva ima svoju jezgrenu dretvu; te „many to many“, gdje više korisničkih dretvi može koristiti više jezgrenih dretvi, ali ne nužno u omjeru jedan na jedan.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 554,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Što je utrkivanje  i kada nastaje?",
    "answer": "Utrkivanje nastaje kada više dretvi istovremeno pokušava pristupiti i mijenjati zajedničke resurse, a redoslijed izvršavanja tih operacija nije definiran. To dovodi do neočekivanih ponašanja programa ili pogrešnih rezultata. Utrkivanje se obično događa u kritičnim sekcijama koda gdje se provode operacije tipa \"read-modify-write\" ili \"check-then-act\".",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 555,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Što je sinkronizacija i kako pomaže kod upravljanja dretvama?",
    "answer": "Sinkronizacija je mehanizam koji rješava probleme poput utrkivanja među dretvama. Uključuje korištenje atomskih operacija, semafora i međusobnog isključivanja (mutex). ",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 556,
  "fields": {
    "lecture_id": 9,
    "subject": 3,
    "question": "Kako radi mutex?",
    "answer": "Mutex radi slično binarnom semaforu, ali se temelji na zaključavanju resursa kako bi se osiguralo da samo jedna dretva u određenom trenutku ima pristup kritičnoj sekciji.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 557,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što je međuprocesna komunikacija?",
    "answer": "Međuprocesna komunikacija (IPC) je mehanizam koji operacijski sustav pruža kako bi procesi mogli međusobno komunicirati i upravljati dijeljenim resursima. Omogućuje sinkronizaciju i razmjenu podataka među procesima koji se izvršavaju istovremeno.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 558,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira komunikacija putem dijeljene memorije?",
    "answer": "Komunikacija putem dijeljene memorije podrazumijeva pisanje i čitanje podataka u zajednički memorijski prostor. Procesi koji koriste dijeljenu memoriju odmah vide promjene, što čini ovu metodu najbržom. Međutim, zahtijeva pažljivo upravljanje pristupom pomoću semafora kako bi se izbjegli problemi istovremenog pristupa, slično kao u višedretvenim programima.",
    "link": "https://www.geeksforgeeks.org/inter-process-communication-ipc-shared-memory/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 559,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što je memorijsko mapiranje i kako se koristi u IPC-u?",
    "answer": "Memorijsko mapiranje omogućuje procesima da komuniciraju putem datoteka koje su mapirane u njihovu memoriju. Operacijski sustav upravlja pristupom datotekama, a procesi tretiraju mapirani dio kao da je dio njihove glavne memorije. Promjene u memoriji automatski se prenose u povezane datoteke.",
    "link": "https://learn.microsoft.com/en-us/windows/win32/memory/creating-a-file-mapping-object"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 560,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira cjevovod u međuprocesnoj komunikaciji?",
    "answer": "Cjevovod je jednosmjeran kanal između dva procesa. Jedan proces upisuje podatke, dok drugi čita. Najčešće se koristi između povezanih procesa, poput roditeljskog i podprocesa. Cjevovod postoji samo dok su povezani procesi aktivni.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 561,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Po čemu se imenovani cjevovod razlikuje od običnog cjevovoda?",
    "answer": "Imenovani cjevovod (FIFO) ima ime u datotečnom sustavu, što omogućuje komunikaciju i između nepovezanih procesa. Procesi mogu neovisno otvarati, zatvarati, čitati i pisati u FIFO.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 562,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Kako funkcionira komunikacija porukama?",
    "answer": "Komunikacija porukama omogućuje slanje i primanje poruka putem redova poruka. Poruke se obično obrađuju redoslijedom dolaska, ali postoji mogućnost da se pojedine poruke ciljano povuku prije nego dođu na red, što pruža veću fleksibilnost od FIFO.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 563,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Što su signali i kako se koriste u IPC-u?",
    "answer": "Signali su oblik softverskih prekida koje procesi koriste za obavještavanje drugih procesa o određenim događajima. Signale može slati drugi proces ili jezgra sustava. Kad proces primi signal, može izvršiti određenu funkciju poznatu kao signalni rukovatelj (handler).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 564,
  "fields": {
    "lecture_id": 10,
    "subject": 3,
    "question": "Koji oblik međuprocesne komunikacije će biti obrađen sljedeći tjedan?",
    "answer": "Sljedeći tjedan planira se obrada IPC-a putem utičnica (sockets), koje omogućuju komunikaciju između procesa na različitim računalima putem mreže.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 565,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Što su utičnice u kontekstu međuprocesne komunikacije?",
    "answer": "Utičnice su mehanizam koji omogućuje međuprocesnu komunikaciju između više procesa na istom računalu ili između računala unutar iste mreže. Podaci se šalju u obliku paketa, a najčešće se koristi model poslužitelj-klijent. Utičnice omogućuju fleksibilan i standardiziran način komunikacije putem mreže.",
    "link": "https://en.wikipedia.org/wiki/Network_socket"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 566,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koje je tri stvari potrebno definirati prilikom stvaranja socket-a?",
    "answer": "Prilikom stvaranja socket-a potrebno je definirati stil komunikacije, namespace i protokol. Stil komunikacije određuje način na koji se podaci prenose, namespace određuje adresni prostor i način na koji se socket identificira, a protokol definira pravila prijenosa podataka između krajnjih točaka komunikacije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 567,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koje su osnovne razlike između stream i datagram utičnica?",
    "answer": "Stream utičnice predstavljaju oblik komunikacije koji je pouzdan i osigurava da svi paketi stignu na odredište redoslijedom kojim su poslani. Ako neki paket ne stigne, automatski se ponovno šalje, što omogućuje točnu i sigurnu isporuku podataka. Takav način rada nalikuje TCP protokolu. S druge strane, datagram utičnice ne garantiraju isporuku paketa niti njihov redoslijed, već se fokusiraju na brzinu prijenosa. U slučaju gubitka paketa, nema ponovnog slanja. Ovakav način rada podsjeća na UDP komunikaciju, gdje je brzina prioritet nad pouzdanošću.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 568,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Što predstavlja namespace kod socket-a?",
    "answer": "Namespace kod socket-a predstavlja način na koji se adresira jedna krajnja točka komunikacije. Ako se koristi lokalni namespace, adresa se odnosi na datoteku u datotečnom sustavu, čime se socket identificira pomoću imena datoteke. Ako se koristi mrežni namespace, adresa socket-a sastoji se od IP adrese hosta i broja porta, čime se omogućuje komunikacija između udaljenih računala preko mreže.",
    "link": "https://en.wikipedia.org/wiki/Unix_domain_socket"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 569,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koju ulogu ima protokol kod socket-a?",
    "answer": "Protokol kod socket-a određuje način na koji će se podaci prenositi između procesa. On definira pravila komunikacije i ponašanje tijekom razmjene informacija. Neki od najčešće korištenih protokola su TCP/IP, koji osigurava pouzdan prijenos podataka, i UDP, koji omogućuje brži ali manje pouzdan prijenos. Osim mrežnih protokola, za lokalnu komunikaciju koristi se i UNIX lokalni protokol, dok se u specifičnim okruženjima može naići na starije protokole poput AppleTalk-a.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 570,
  "fields": {
    "lecture_id": 11,
    "subject": 3,
    "question": "Koji su osnovni sistemski pozivi pri radu sa socket-ima?",
    "answer": "Pri radu sa socket-ima koristi se niz sistemskih poziva koji omogućuju stvaranje i upravljanje socket-ima. Proces započinje stvaranjem socket-a pomoću poziva socket, nakon čega se socket povezuje s adresom pomoću bind ako se radi o poslužitelju. Potom se socket stavlja u stanje slušanja s pozivom listen, a klijent koristi connect kako bi uspostavio vezu. Kada poslužitelj primi zahtjev, koristi accept za prihvaćanje veze. Za razmjenu podataka koriste se read i write, dok se na kraju veze socket zatvara pozivom close.",
    "link": "https://en.wikipedia.org/wiki/Berkeley_sockets"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 571,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je upravljanje memorijom?",
    "answer": "Upravljanje memorijom je funkcionalnost operacijskog sustava kojom se omogućuje učitavanje više procesa u radnu memoriju i raspoređivanje te memorije među njima. Operacijski sustav vodi računa o tome koji dijelovi memorije su zauzeti, koji su slobodni, i kako optimalno dodijeliti memorijske resurse svakom procesu tako da se postigne učinkovito korištenje memorije i izbjegnu konflikti među procesima.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 572,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji su problemi povezani s fiksnim particioniranjem memorije?",
    "answer": "Kod fiksnog particioniranja memorije, ukupna memorija podijeljena je na unaprijed definirane blokove fiksne veličine. Glavni problem ovog pristupa je unutarnja fragmentacija, koja nastaje kada proces zauzme više memorije nego što mu je stvarno potrebno, ali se svejedno dodjeljuje cijeli blok. Zbog toga dolazi do neučinkovitog korištenja memorije, a dodatni problem je i ograničen broj procesa koji mogu istovremeno biti aktivni, jer broj particija definira maksimalan broj procesa.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 573,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji je glavni problem dinamičkog particioniranja memorije?",
    "answer": "Glavni problem kod dinamičkog particioniranja memorije je vanjska fragmentacija. To se događa kada tijekom vremena u memoriji nastanu brojni mali, nepovezani slobodni prostori koji zajedno možda čine dovoljno memorije za novi proces, ali zbog njihove razdvojenosti operacijski sustav ne može alocirati memoriju u jednom komadu. Zbog toga može doći do situacije u kojoj se novi proces ne može učitati, iako ukupno ima dovoljno slobodne memorije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 574,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je zbijanje memorije i kada se koristi?",
    "answer": "Zbijanje memorije je postupak kojim operacijski sustav premješta podatke u memoriji s ciljem uklanjanja vanjske fragmentacije. Premještanjem aktivnih procesa u jedan dio memorije, oslobađa se kontinuirani blok memorije koji se može dodijeliti novim procesima. Ova operacija povećava učinkovitost korištenja memorije, ali također predstavlja dodatni trošak za sustav jer zahtijeva vrijeme i resurse za pomicanje podataka.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 575,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Koji algoritmi se koriste za dodjelu slobodnih memorijskih blokova?",
    "answer": "Postoji nekoliko algoritama koji se koriste za odabir slobodnih blokova memorije kada novi proces zatraži prostor. Prvi algoritam, First-fit, traži prvi dovoljno veliki blok i odmah ga dodjeljuje. Next-fit je sličan, ali nastavlja pretraživanje od mjesta gdje je prethodna alokacija završila. Best-fit traži najmanji blok koji je dovoljno velik za proces, kako bi se ostavilo što manje neiskorištenog prostora. Suprotno tome, Worst-fit odabire najveći dostupni blok, s namjerom da podijeljeni ostatak nakon alokacije bude dovoljno velik za buduće zahtjeve. Svaki od ovih algoritama ima svoje prednosti i nedostatke u pogledu brzine i količine fragmentacije koju uzrokuje.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 576,
  "fields": {
    "lecture_id": 12,
    "subject": 3,
    "question": "Što je buddy system i kako funkcionira?",
    "answer": "„Buddy system“ je metoda upravljanja memorijom koja predstavlja kompromis između fiksnog i dinamičkog particioniranja. U ovom sustavu, memorija se dijeli na blokove veličine koji su potencije broja dva, a kada je potrebno, veći blokovi se dijele na manje. Ako su dva susjedna bloka slobodna i imaju istu veličinu, oni se mogu ponovno spojiti u veći blok. Ovaj sustav omogućuje fleksibilnu i učinkovitu dodjelu memorije uz smanjenu fragmentaciju i brže pronalaženje slobodnog prostora.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 577,
  "fields": {
    "lecture_id": 13,
    "subject": 3,
    "question": "Koji su osnovni sigurnosni zahtjevi i sigurnosne prijetnje u informacijskim sustavima?",
    "answer": "Sigurnosni zahtjevi informacijskih sustava temelje se na četiri ključna principa: povjerljivosti, integritetu, dostupnosti i autentičnosti. Povjerljivost podrazumijeva da su podaci dostupni samo ovlaštenim osobama, a ne smiju ih presresti treće strane, što se naziva presretanjem. Integritet znači da podaci ostaju neizmijenjeni osim ako ih ne izmijeni netko s odgovarajućim ovlastima, a svako neautorizirano mijenjanje predstavlja sigurnosnu prijetnju poznatu kao modifikacija. Dostupnost osigurava da sustav i njegovi resursi budu dostupni korisnicima kad god su im potrebni, dok je prekid rada ili pristupa sustavu prijetnja koja ugrožava dostupnost. Autentičnost se odnosi na vjerodostojnost komunikacije ili identiteta korisnika, a sigurnosna prijetnja koja ugrožava autentičnost naziva se fabrikacija, jer uključuje lažno predstavljanje ili izmišljanje podataka.",
    "link": "https://ocw.mit.edu/courses/6-858-computer-systems-security-fall-2014/"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 578,
  "fields": {
    "lecture_id": 13,
    "subject": 3,
    "question": "Što je phishing i kako se možemo zaštititi od njega?",
    "answer": "Phishing je oblik kibernetičkog napada u kojem napadač pokušava prevariti korisnika da mu otkrije osjetljive podatke, poput korisničkih imena, lozinki ili podataka o kreditnim karticama, najčešće putem lažnih e-mail poruka ili web stranica koje oponašaju stvarne servise. Osoba koja primi takvu poruku često biva zavedena hitnošću poruke ili poznatim vizualnim identitetom, poput logotipa banke, kako bi bez razmišljanja unijela svoje podatke. Za zaštitu od phishinga preporučuje se korištenje dvofaktorske autentifikacije (2FA), izbjegavanje klikanja na sumnjive poveznice, pažljivo provjeravanje adresa pošiljatelja te edukacija o najnovijim vrstama napada.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 579,
  "fields": {
    "lecture_id": 13,
    "subject": 3,
    "question": "Kako funkcionira probijanje lozinki i koje metode se koriste?",
    "answer": "Probijanje lozinki, poznato i kao „password cracking“, je proces kojim napadač pokušava otkriti korisničku lozinku koristeći razne metode, najčešće uz pomoć specijaliziranih alata kao što je John the Ripper. Ovaj alat koristi tri osnovna moda rada. U prvom, takozvanom „single crack“ modu, alat koristi poznate informacije poput korisničkog imena za pogađanje lozinki. U drugom, „wordlist crack“ modu, koristi unaprijed pripremljene popise najčešće korištenih lozinki. U trećem, „incremental crack“ modu, isprobavaju se sve moguće kombinacije znakova, što je vrlo zahtjevno i dugotrajno, ali najučinkovitije kada druge metode ne uspiju. Za izvođenje ovakvih napada napadač mora imati pristup hash vrijednostima lozinki koje su pohranjene, primjerice, u datoteci /etc/shadow na Linux sustavu.",
    "link": "https://github.com/openwall/john"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 580,
  "fields": {
    "lecture_id": 13,
    "subject": 3,
    "question": "Koje su moguće posljedice kibernetičkih napada za fizičke i pravne osobe?",
    "answer": "Kibernetički napadi mogu imati ozbiljne posljedice kako za pojedince tako i za organizacije. Za fizičke osobe, posljedice uključuju krađu identiteta, financijske gubitke, emocionalni stres, osjećaj srama i nesigurnosti. Napad žrtvu često ostavlja s narušenim povjerenjem u tehnologiju i potrebu da promijeni lozinke, kontaktira banku i eventualno obustavi ili zamijeni svoje platne kartice. Za pravne osobe, posljedice uključuju prekid poslovanja, velike financijske gubitke, gubitak povjerenja korisnika i javnosti, curenje intelektualnog vlasništva te potencijalne pravne posljedice, osobito u slučaju nepoštivanja zakona o zaštiti osobnih podataka.",
    "link": "https://www.iii.org/fact-statistic/facts-statistics-identity-theft-and-cybercrime"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 581,
  "fields": {
    "lecture_id": 13,
    "subject": 3,
    "question": "Koja je razlika između sigurnosti i privatnosti?",
    "answer": "Sigurnost i privatnost su povezani, ali različiti koncepti. Sigurnost se odnosi na zaštitu sustava i podataka od kibernetičkih prijetnji, hakera i neovlaštenog pristupa, čime se sprječavaju curenja podataka. Privatnost se odnosi na pravo pojedinca da odlučuje kako se njegovi podaci koriste, s kime se dijele i da ostane slobodan od neželjenog nadzora ili smetnji. Primjer koji to jasno ilustrira je zaključavanje vrata stana kako bi se spriječio ulazak neovlaštenih osoba (sigurnost), nasuprot zatvaranju vrata sobe kako bi osoba mogla provesti vrijeme u miru (privatnost).",
    "link": "https://www.youtube.com/watch?v=pcSlowAhvUk"
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 582,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Karakteristike polling-a",
    "answer": "Softver povremeno provjerava; gubljenje puno CPU ciklusa; pokreće ga softver; javlja se periodično.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 583,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Karakteristike prekida (Interrupt)",
    "answer": "CPU poduzima radnje samo ako se dogodi događaj; ne troši puno CPU ciklusa; pokreće ga hardver ili softver; javlja se u bilo koje vrijeme.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 584,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Što je i čemu služi NVIC?",
    "answer": "Nested Vectored Interrupt Controller; koordinira više izvora prekida; omogućuje ili onemogućuje određeni prekid.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 585,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Kako se omogućuje prekid (interrupt)?",
    "answer": "1. Isprogramirajte periferni kontrolni registar da dopustite generiranje prekida; 2. Isprogramirajte NVIC da prihvati prekid.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 586,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Korištenje LR registra prilikom obrade prekida",
    "answer": "LR sprema kod koji opisuje hoće li unstacking biti MSP ili PSP; ovisno o prethodnoj aritmetičkoj operaciji (MSP ako nije bilo); potrebno spremiti LR ako se ulazi u drugu subrutinu unutar ISR-a.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 587,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Auto-(un)stacking prilikom obrade prekida",
    "answer": "Unstacking se događa automatski pri izlasku iz ISR-a; brišu se registri koji su bili na stacku.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 588,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Tablice prekidnih vektora i negativni brojevi prekida",
    "answer": "255 ukupno; System Exceptions (-16 do -1) - ARM defined; Peripheral Interrupts (0 do 239) - chip vendor specific.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 589,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Maskiranje prekida",
    "answer": "BASEPRI: onemogućuje prekide određenog ili višeg prioriteta; PRIMASK: onemogućuje sve iznimke; FAULTMASK: kao PRIMASK ali mijenja trenutni prioritet na -1.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 590,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Omogućavanje i prioriteti prekida",
    "answer": "ISER registri za uključivanje; ICER za isključivanje (npr. ISER0, ISER1...); manji broj = veći prioritet; IP registar postavlja prioritete (preempt + subprioritet).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 591,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "SysTick - način rada i primjena",
    "answer": "Koristi se za time delay ili polling; ISR i main se izmjenjuju; Period = (SysTick_LOAD + 1) * Clock Period = 7 * Clock Period.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 592,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Kako se konfigurira SysTick?",
    "answer": "1. Postavi trenutačnu vrijednost na nulu; 2. Postavi READ vrijednost; 3. Postavi takt, omogući prekid i timer; 4. Postavi prioritet prekida; 5. Napravi ISR (npr. ms_counter++); 6. Delay funkcija koja čeka određeno vrijeme.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 593,
  "fields": {
    "lecture_id": 11,
    "subject": 2,
    "question": "Vanjski prekidi na GPIO pinovima - konfiguracija",
    "answer": "1. Inicijalizacija GPIO (clock, mode, pull); 2. Blink funkcija; 3. Uključi syscfg (APB2EN); 4. EXTI IM maska i trigger; 5. ISERx i prioritet; 6. Handler funkcije.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 594,
  "fields": {
    "lecture_id": 12,
    "subject": 2,
    "question": "Razlika između floating i fixed point aritmetike",
    "answer": "Floating: veći raspon, kraće vrijeme razvoja; Fixed: manja cijena, više bitova za preciznost, bolje performanse, dulje vrijeme razvoja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 595,
  "fields": {
    "lecture_id": 12,
    "subject": 2,
    "question": "4 načina zaokruživanja decimala u IEEE 754",
    "answer": "Na najbližu vrijednost; prema nuli (truncate); prema +∞; prema -∞.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 596,
  "fields": {
    "lecture_id": 12,
    "subject": 2,
    "question": "Jesu li floating point brojevi decimalni brojevi?",
    "answer": "Ne",
    "link": "oni su samo približne vrijednosti decimalnih brojeva."
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 597,
  "fields": {
    "lecture_id": 15,
    "subject": 2,
    "question": "Tri stanja digitalnog ulaza",
    "answer": "High; Low; Visoka impedancija.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 598,
  "fields": {
    "lecture_id": 15,
    "subject": 2,
    "question": "GPIO načini rada (BSRR, BRR, MODE registri)",
    "answer": "MODER: input/output/alternate/analog; BSRR: set/reset pinova; BRR: reset pinova.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 599,
  "fields": {
    "lecture_id": 15,
    "subject": 2,
    "question": "Pull-up otpornik - svrha i rad",
    "answer": "Drži pin na Vcc kad nema signala; izbjegava smetnje; pritiskom tipke ide u 0.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 600,
  "fields": {
    "lecture_id": 15,
    "subject": 2,
    "question": "Pull-down otpornik - svrha i rad",
    "answer": "Drži pin na 0 kad nema signala; izbjegava smetnje; pritiskom tipke ide u 1.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 601,
  "fields": {
    "lecture_id": 15,
    "subject": 2,
    "question": "Open-drain izlaz - rad i primjena",
    "answer": "Kad je 0 -> spoj na GND; kad je 1 -> lebdi (pullup daje 1); koristi se u I2C za dijeljenje linija.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 602,
  "fields": {
    "lecture_id": 15,
    "subject": 2,
    "question": "Schmittov okidački sklop - rad",
    "answer": "Pruža histerezu za analogne ulaze; ignorira šum između dvije granice; daje čist signal.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 603,
  "fields": {
    "lecture_id": 15,
    "subject": 2,
    "question": "Čitanje 4x3 tipkovnice",
    "answer": "Redovi su output, stupci input; detekcija po linijama; kombinacija 0/1 u redovima i stupcima određuje tipku.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 604,
  "fields": {
    "lecture_id": 15,
    "subject": 2,
    "question": "Debounce problem na primjeru prekida",
    "answer": "Tipka kod pritiska uzrokuje višestruke brze promjene stanja (šum); potrebno softversko filtriranje ili hardverski debounce.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 605,
  "fields": {
    "lecture_id": 16,
    "subject": 2,
    "question": "RTC i primjena",
    "answer": "Real Time Clock; prikazuje datum, vrijeme; troši malo energije; koristi se za alarme, tracking, wake-up.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 606,
  "fields": {
    "lecture_id": 16,
    "subject": 2,
    "question": "Timer u input capture načinu",
    "answer": "Reagiranje na edge (rising/falling); CCR bilježi vrijeme; ISR računa vrijeme između dva događaja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 607,
  "fields": {
    "lecture_id": 16,
    "subject": 2,
    "question": "Timer u output compare načinu s toggle",
    "answer": "Prescaler, ARR i CCR konfigurirani; kada counter dosegne CCR -> toggle pin.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 608,
  "fields": {
    "lecture_id": 16,
    "subject": 2,
    "question": "Izračun perioda izlaznog signala timera",
    "answer": "Period = ((ARR+1)*(PSC+1))/f_source",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 609,
  "fields": {
    "lecture_id": 17,
    "subject": 2,
    "question": "Za što se koristi DMA?",
    "answer": "Za prijenos podataka bez korištenja CPU-a; poboljšava performanse.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 610,
  "fields": {
    "lecture_id": 17,
    "subject": 2,
    "question": "Ključni DMA registri",
    "answer": "CMAR (mem. adresa); CPAR (perif. adresa); CNDTR (broj podataka); CCR (konfiguracija).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 611,
  "fields": {
    "lecture_id": 18,
    "subject": 2,
    "question": "ADC - funkcija",
    "answer": "Pretvara analogni signal u digitalni (diskretan) oblik uz pomoć rezolucije i uzorkovanja.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 612,
  "fields": {
    "lecture_id": 18,
    "subject": 2,
    "question": "Što je rezolucija ADC-a?",
    "answer": "Broj bitova u digitalnom izlazu; veća rezolucija = veća preciznost.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 613,
  "fields": {
    "lecture_id": 18,
    "subject": 2,
    "question": "Što je kvantizacijska greška?",
    "answer": "Greška +-1/2 LSB; LSB = Vref/(2^n - 1).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 614,
  "fields": {
    "lecture_id": 18,
    "subject": 2,
    "question": "Stopa uzorkovanja ADC-a?",
    "answer": "Broj uzoraka po jedinici vremena.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 615,
  "fields": {
    "lecture_id": 18,
    "subject": 2,
    "question": "ADC vrijeme pretvorbe",
    "answer": "T(ADC) = T(uzorkovanja) + T(pretvorbe).",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 616,
  "fields": {
    "lecture_id": 18,
    "subject": 2,
    "question": "Funkcija DAC-a",
    "answer": "Pretvara digitalne vrijednosti u analogni napon.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 617,
  "fields": {
    "lecture_id": 18,
    "subject": 2,
    "question": "Kako se računa DAC izlaz?",
    "answer": "DAC = Vref * DigitalnaVrijednost / ((2^N)-1)",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 618,
  "fields": {
    "lecture_id": 18,
    "subject": 2,
    "question": "Gdje se koristi DAC?",
    "answer": "Za digitalni audio, generiranje valnih oblika.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 619,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "Kako radi I2C?",
    "answer": "Dvosmjerni serijski protokol; koristi SDA i SCL; open-drain linije s pull-up otpornicima; START i STOP definirani po promjeni SDA dok je SCL HIGH.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 620,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "Karakteristike I2C",
    "answer": "Serijski; bajtni; više mastera/slavova; koristi dvije linije; zahtijeva GND.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 621,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "Modovi rada I2C",
    "answer": "Master-sender; Master-receiver; Slave-sender; Slave-receiver.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 622,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "Što je arbitraža na I2C?",
    "answer": "Kad više mastera šalje; prvi koji detektira razliku na SDA gubi pravo slanja; sprječava sudar.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 623,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "Kako radi SPI?",
    "answer": "Master upravlja komunikacijom; koristi SCLK, MOSI, MISO, SS; full-duplex; CPOL i CPHA definiraju takt.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 624,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "Karakteristike SPI",
    "answer": "Veća brzina (10+ Mbps); full-duplex; jedan master; više slave uređaja; nema potvrde; više žica.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 625,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "SPI vs I2C",
    "answer": "SPI: brži, više žica, bez višestrukih mastera; I2C: jednostavniji, 2 žice, podrška za više mastera.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 626,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "Što je baud frekvencija?",
    "answer": "Broj bitova prenesenih u sekundi.",
    "link": null
  }
},
{
  "model": "chatbot.qaentry",
  "pk": 627,
  "fields": {
    "lecture_id": 19,
    "subject": 2,
    "question": "Kako se računa baud frekvencija?",
    "answer": "baud rate = ((1+OVER8) * f(CK)) / USARTDIV",
    "link": null
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 1,
  "fields": {
    "app_label": "admin",
    "model": "logentry"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 2,
  "fields": {
    "app_label": "auth",
    "model": "permission"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 3,
  "fields": {
    "app_label": "auth",
    "model": "group"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 4,
  "fields": {
    "app_label": "auth",
    "model": "user"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 5,
  "fields": {
    "app_label": "chatbot",
    "model": "subject"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 6,
  "fields": {
    "app_label": "chatbot",
    "model": "qaentry"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 7,
  "fields": {
    "app_label": "contenttypes",
    "model": "contenttype"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 8,
  "fields": {
    "app_label": "sessions",
    "model": "session"
  }
},
{
  "model": "sessions.session",
  "pk": "0b4emsr2h6sp96qnepzbdrjnyo9kgo9q",
  "fields": {
    "session_data": ".eJxVjEEOgkAMRe8yazMpnSrg0j1nmLTTIqhhEgZWxrsLCQvd_vf-e7vI6zLEtdgcR3VXh-70uwmnp0070AdP9-xTnpZ5FL8r_qDFd1ntdTvcv8DAZdjevTTYtgaCvZHAOaFSUEpAgHW7dTAQNZrgAszJrOpBqzoQa7AgGNznC_D4ODo:1uFbth:UJKBHY56ne3fkObfnO_o2XO0uqWHsmD6yxBnvDzwCoM",
    "expire_date": "2025-05-29T16:57:29.329Z"
  }
},
{
  "model": "sessions.session",
  "pk": "5jdk4xi3ppl60j440dnv566g2q34icuu",
  "fields": {
    "session_data": ".eJxVjEEOgkAMRe8yazMpnSrg0j1nmLTTIqhhEgZWxrsLCQvd_vf-e7vI6zLEtdgcR3VXh-70uwmnp0070AdP9-xTnpZ5FL8r_qDFd1ntdTvcv8DAZdjevTTYtgaCvZHAOaFSUEpAgHW7dTAQNZrgAszJrOpBqzoQa7AgGNznC_D4ODo:1uEDrO:6jXzCtpVK7HNNNhRYmrDF6qce1LN18OWfBHAuwp5Sec",
    "expire_date": "2025-05-25T21:05:22.388Z"
  }
},
{
  "model": "sessions.session",
  "pk": "k7jaumckqlvsboyblxnc153tdy18kgta",
  "fields": {
    "session_data": ".eJxVjEEOgkAMRe8yazMpnSrg0j1nmLTTIqhhEgZWxrsLCQvd_vf-e7vI6zLEtdgcR3VXh-70uwmnp0070AdP9-xTnpZ5FL8r_qDFd1ntdTvcv8DAZdjevTTYtgaCvZHAOaFSUEpAgHW7dTAQNZrgAszJrOpBqzoQa7AgGNznC_D4ODo:1uFGHa:BcKtr9uqhdansMM0Nksug4-t79UPDUlxudfN2vJqmYA",
    "expire_date": "2025-05-28T17:52:42.632Z"
  }
},
{
  "model": "sessions.session",
  "pk": "lyp5tpzhls73eqkbe1w9jvpfdgcd10vm",
  "fields": {
    "session_data": ".eJxVjDsOwjAUBO_iGlmJfzGU9DmDtX7PxgHkSHFSIe4OkVJAuzOzLxGwrSVsLS1hYnERvTj9bhH0SHUHfEe9zZLmui5TlLsiD9rkOHN6Xg_376CglW_tyWafYjJsPGfFVsV-UJp1ZsBZS8ZDRSARAWcN5o46TQ4DO7KWxfsDHPE5ng:1uEDEf:R-1CNhw3oCNo7dsjaixO87Xw0ImS3HCIOCHubWOZ1Oo",
    "expire_date": "2025-05-25T20:25:21.786Z"
  }
},
{
  "model": "sessions.session",
  "pk": "uxedzbj1c8r2z6h8y8deqbgvzmkc8l18",
  "fields": {
    "session_data": ".eJxVjEEOgkAMRe8yazMpnSrg0j1nmLTTIqhhEgZWxrsLCQvd_vf-e7vI6zLEtdgcR3VXh-70uwmnp0070AdP9-xTnpZ5FL8r_qDFd1ntdTvcv8DAZdjevTTYtgaCvZHAOaFSUEpAgHW7dTAQNZrgAszJrOpBqzoQa7AgGNznC_D4ODo:1uFeT9:01nV7URB60wSP4RxD_5aOdcuI8_2jfqPHuArKrL-_fY",
    "expire_date": "2025-05-29T19:42:15.233Z"
  }
}
]
